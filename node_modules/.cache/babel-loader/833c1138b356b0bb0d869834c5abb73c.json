{"ast":null,"code":"import { InternalDate } from \"../../../../lib/date/InternalDate\";\nimport { InternalDateGetter } from \"../../../../lib/date/InternalDateGetter\";\nimport { InternalDateTransformer } from \"../../../../lib/date/InternalDateTransformer\";\nimport { InternalDateComponentType, InternalDateValidateCheck } from \"../../../../lib/date/types\";\nimport { inputNumber } from \"../inputNumber\";\nexport var InternalDateMediator = /*#__PURE__*/function () {\n  function InternalDateMediator() {\n    var _this = this;\n\n    this.iDate = new InternalDate();\n\n    this.update = function (props, locale) {\n      var start = _this.iDate.getRangeStart();\n\n      var min = start && start.toInternalString();\n\n      var end = _this.iDate.getRangeEnd();\n\n      var max = end && end.toInternalString();\n      var order = locale.order,\n          separator = locale.separator;\n\n      _this.iDate.setOrder(order).setSeparator(separator);\n\n      if (props.minDate !== min) {\n        _this.iDate.setRangeStart(props.minDate ? new InternalDate({\n          order: order,\n          separator: separator,\n          value: props.minDate\n        }) : null);\n      }\n\n      if (props.maxDate !== max) {\n        _this.iDate.setRangeEnd(props.maxDate ? new InternalDate({\n          order: order,\n          separator: separator,\n          value: props.maxDate\n        }) : null);\n      }\n\n      if (!props.value || props.value !== _this.iDate.toInternalString()) {\n        _this.iDate.parseInternalValue(props.value);\n      }\n\n      return _this;\n    };\n\n    this.paste = function (pasted) {\n      _this.iDate.parseValue(pasted).restore().cutOffExcess();\n\n      return _this;\n    };\n\n    this.restore = function () {\n      if (_this.iDate.isIncomplete()) {\n        var restored = _this.iDate.clone().restore();\n\n        if (!_this.iDate.isEqual(restored)) {\n          _this.iDate.duplicateOf(restored);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    this.getFragments = function () {\n      return _this.iDate.toFragments({\n        withSeparator: true,\n        withPad: true\n      });\n    };\n\n    this.deleteOneCharRight = function (type, inputMode) {\n      var prev = _this.iDate.get(type);\n\n      prev = String(inputMode ? prev : InternalDateTransformer.padDateComponent(type, prev));\n      var next = prev.replace(/.$/, '') || null;\n\n      _this.iDate.set(type, next);\n    };\n\n    this.isChangedLocale = function (locale) {\n      return locale.order !== _this.iDate.getOrder() || locale.separator !== _this.iDate.getSeparator();\n    };\n\n    this.isNull = function (type) {\n      return _this.iDate.get(type) === null;\n    };\n\n    this.isEmpty = function () {\n      return _this.iDate.isEmpty();\n    };\n\n    this.get = function (type) {\n      return _this.iDate.get(type);\n    };\n\n    this.clear = function (type) {\n      return _this.iDate.set(type, null);\n    };\n\n    this.validateString = function (value) {\n      return InternalDateTransformer.parseValueToDate(value, _this.iDate.getOrder()) !== null;\n    };\n\n    this.getString = function () {\n      return _this.iDate.isEmpty() ? '' : _this.iDate.toString();\n    };\n\n    this.getInternalString = function () {\n      return _this.iDate.isEmpty() ? '' : _this.iDate.toInternalString();\n    };\n\n    this.getTypesOrder = function () {\n      return _this.iDate.toFragments().map(function (_ref) {\n        var type = _ref.type;\n        return type;\n      });\n    };\n\n    this.getLeftmostType = function () {\n      return _this.getTypesOrder()[0];\n    };\n\n    this.getRightmostType = function () {\n      return _this.getTypesOrder()[2];\n    };\n  }\n\n  var _proto = InternalDateMediator.prototype;\n\n  _proto.inputKey = function inputKey(key, type, inputMode) {\n    var prevValue = this.iDate.get(type);\n\n    if (type === null) {\n      type = this.getLeftmostType();\n      this.clear(type);\n    }\n\n    if (type !== InternalDateComponentType.Year) {\n      this.iDate.cutOffExcess(type);\n    } else {\n      this.iDate.restore(type);\n    }\n\n    var _inputNumber = inputNumber(type, prevValue, key, inputMode),\n        nextValue = _inputNumber.nextValue,\n        nextInputMode = _inputNumber.nextInputMode;\n\n    this.iDate.set(type, nextValue);\n    return nextInputMode;\n  };\n\n  _proto.shiftDateComponent = function shiftDateComponent(type, step) {\n    type = type === null ? this.getLeftmostType() : type;\n    var iDate = this.iDate.clone();\n    var isValidRange = iDate.validate({\n      checks: [InternalDateValidateCheck.Range]\n    });\n    var start = iDate.getRangeStart();\n    var end = iDate.getRangeEnd();\n\n    if (!isValidRange) {\n      // Удерживаем дату в заданном диапазоне\n      if (start && InternalDateGetter.max([iDate, start]) === start) {\n        iDate.duplicateOf(start);\n      } else if (end && InternalDateGetter.min([iDate, end]) === end) {\n        iDate.duplicateOf(end);\n      }\n    } else {\n      var clone = iDate.clone().shift(type, step, {\n        isRange: false,\n        isLoop: true\n      });\n\n      if (clone.validate({\n        checks: [InternalDateValidateCheck.Range]\n      })) {\n        iDate.duplicateOf(clone);\n      }\n    }\n\n    var changed = !this.iDate.isEqualComponentDate(type, iDate);\n    this.iDate = iDate;\n    return changed;\n  };\n\n  _proto.getShiftedType = function getShiftedType(type, step) {\n    var typesOrder = this.getTypesOrder();\n    var index = type === null ? 0 : typesOrder.indexOf(type);\n    var nextIndex = index + step; // Если выделено всё поле, то в завимости от направления перемещения, выделям крайний компонент\n\n    if (type === InternalDateComponentType.All) {\n      return step < 0 ? typesOrder[0] : typesOrder[2];\n    } // Если текущий компонент \"год\", и он не пуст, то при перемещении выделения \"восстанавливаем\" значение года\n\n\n    if (type === InternalDateComponentType.Year && this.iDate.getYear() !== null) {\n      this.iDate.restore(type);\n    }\n\n    var shiftedType = typesOrder[nextIndex];\n    return typeof shiftedType === 'number' ? shiftedType : type;\n  };\n\n  return InternalDateMediator;\n}();","map":{"version":3,"sources":["C:/Users/ravka/Desktop/react-typescript-task/node_modules/@skbkontur/react-ui/components/DateInput/helpers/InternalDateMediator/InternalDateMediator.js"],"names":["InternalDate","InternalDateGetter","InternalDateTransformer","InternalDateComponentType","InternalDateValidateCheck","inputNumber","InternalDateMediator","_this","iDate","update","props","locale","start","getRangeStart","min","toInternalString","end","getRangeEnd","max","order","separator","setOrder","setSeparator","minDate","setRangeStart","value","maxDate","setRangeEnd","parseInternalValue","paste","pasted","parseValue","restore","cutOffExcess","isIncomplete","restored","clone","isEqual","duplicateOf","getFragments","toFragments","withSeparator","withPad","deleteOneCharRight","type","inputMode","prev","get","String","padDateComponent","next","replace","set","isChangedLocale","getOrder","getSeparator","isNull","isEmpty","clear","validateString","parseValueToDate","getString","toString","getInternalString","getTypesOrder","map","_ref","getLeftmostType","getRightmostType","_proto","prototype","inputKey","key","prevValue","Year","_inputNumber","nextValue","nextInputMode","shiftDateComponent","step","isValidRange","validate","checks","Range","shift","isRange","isLoop","changed","isEqualComponentDate","getShiftedType","typesOrder","index","indexOf","nextIndex","All","getYear","shiftedType"],"mappings":"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","sourcesContent":["import { InternalDate } from \"../../../../lib/date/InternalDate\";\nimport { InternalDateGetter } from \"../../../../lib/date/InternalDateGetter\";\nimport { InternalDateTransformer } from \"../../../../lib/date/InternalDateTransformer\";\nimport { InternalDateComponentType, InternalDateValidateCheck } from \"../../../../lib/date/types\";\nimport { inputNumber } from \"../inputNumber\";\nexport var InternalDateMediator =\n/*#__PURE__*/\nfunction () {\n  function InternalDateMediator() {\n    var _this = this;\n\n    this.iDate = new InternalDate();\n\n    this.update = function (props, locale) {\n      var start = _this.iDate.getRangeStart();\n\n      var min = start && start.toInternalString();\n\n      var end = _this.iDate.getRangeEnd();\n\n      var max = end && end.toInternalString();\n      var order = locale.order,\n          separator = locale.separator;\n\n      _this.iDate.setOrder(order).setSeparator(separator);\n\n      if (props.minDate !== min) {\n        _this.iDate.setRangeStart(props.minDate ? new InternalDate({\n          order: order,\n          separator: separator,\n          value: props.minDate\n        }) : null);\n      }\n\n      if (props.maxDate !== max) {\n        _this.iDate.setRangeEnd(props.maxDate ? new InternalDate({\n          order: order,\n          separator: separator,\n          value: props.maxDate\n        }) : null);\n      }\n\n      if (!props.value || props.value !== _this.iDate.toInternalString()) {\n        _this.iDate.parseInternalValue(props.value);\n      }\n\n      return _this;\n    };\n\n    this.paste = function (pasted) {\n      _this.iDate.parseValue(pasted).restore().cutOffExcess();\n\n      return _this;\n    };\n\n    this.restore = function () {\n      if (_this.iDate.isIncomplete()) {\n        var restored = _this.iDate.clone().restore();\n\n        if (!_this.iDate.isEqual(restored)) {\n          _this.iDate.duplicateOf(restored);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    this.getFragments = function () {\n      return _this.iDate.toFragments({\n        withSeparator: true,\n        withPad: true\n      });\n    };\n\n    this.deleteOneCharRight = function (type, inputMode) {\n      var prev = _this.iDate.get(type);\n\n      prev = String(inputMode ? prev : InternalDateTransformer.padDateComponent(type, prev));\n      var next = prev.replace(/.$/, '') || null;\n\n      _this.iDate.set(type, next);\n    };\n\n    this.isChangedLocale = function (locale) {\n      return locale.order !== _this.iDate.getOrder() || locale.separator !== _this.iDate.getSeparator();\n    };\n\n    this.isNull = function (type) {\n      return _this.iDate.get(type) === null;\n    };\n\n    this.isEmpty = function () {\n      return _this.iDate.isEmpty();\n    };\n\n    this.get = function (type) {\n      return _this.iDate.get(type);\n    };\n\n    this.clear = function (type) {\n      return _this.iDate.set(type, null);\n    };\n\n    this.validateString = function (value) {\n      return InternalDateTransformer.parseValueToDate(value, _this.iDate.getOrder()) !== null;\n    };\n\n    this.getString = function () {\n      return _this.iDate.isEmpty() ? '' : _this.iDate.toString();\n    };\n\n    this.getInternalString = function () {\n      return _this.iDate.isEmpty() ? '' : _this.iDate.toInternalString();\n    };\n\n    this.getTypesOrder = function () {\n      return _this.iDate.toFragments().map(function (_ref) {\n        var type = _ref.type;\n        return type;\n      });\n    };\n\n    this.getLeftmostType = function () {\n      return _this.getTypesOrder()[0];\n    };\n\n    this.getRightmostType = function () {\n      return _this.getTypesOrder()[2];\n    };\n  }\n\n  var _proto = InternalDateMediator.prototype;\n\n  _proto.inputKey = function inputKey(key, type, inputMode) {\n    var prevValue = this.iDate.get(type);\n\n    if (type === null) {\n      type = this.getLeftmostType();\n      this.clear(type);\n    }\n\n    if (type !== InternalDateComponentType.Year) {\n      this.iDate.cutOffExcess(type);\n    } else {\n      this.iDate.restore(type);\n    }\n\n    var _inputNumber = inputNumber(type, prevValue, key, inputMode),\n        nextValue = _inputNumber.nextValue,\n        nextInputMode = _inputNumber.nextInputMode;\n\n    this.iDate.set(type, nextValue);\n    return nextInputMode;\n  };\n\n  _proto.shiftDateComponent = function shiftDateComponent(type, step) {\n    type = type === null ? this.getLeftmostType() : type;\n    var iDate = this.iDate.clone();\n    var isValidRange = iDate.validate({\n      checks: [InternalDateValidateCheck.Range]\n    });\n    var start = iDate.getRangeStart();\n    var end = iDate.getRangeEnd();\n\n    if (!isValidRange) {\n      // Удерживаем дату в заданном диапазоне\n      if (start && InternalDateGetter.max([iDate, start]) === start) {\n        iDate.duplicateOf(start);\n      } else if (end && InternalDateGetter.min([iDate, end]) === end) {\n        iDate.duplicateOf(end);\n      }\n    } else {\n      var clone = iDate.clone().shift(type, step, {\n        isRange: false,\n        isLoop: true\n      });\n\n      if (clone.validate({\n        checks: [InternalDateValidateCheck.Range]\n      })) {\n        iDate.duplicateOf(clone);\n      }\n    }\n\n    var changed = !this.iDate.isEqualComponentDate(type, iDate);\n    this.iDate = iDate;\n    return changed;\n  };\n\n  _proto.getShiftedType = function getShiftedType(type, step) {\n    var typesOrder = this.getTypesOrder();\n    var index = type === null ? 0 : typesOrder.indexOf(type);\n    var nextIndex = index + step; // Если выделено всё поле, то в завимости от направления перемещения, выделям крайний компонент\n\n    if (type === InternalDateComponentType.All) {\n      return step < 0 ? typesOrder[0] : typesOrder[2];\n    } // Если текущий компонент \"год\", и он не пуст, то при перемещении выделения \"восстанавливаем\" значение года\n\n\n    if (type === InternalDateComponentType.Year && this.iDate.getYear() !== null) {\n      this.iDate.restore(type);\n    }\n\n    var shiftedType = typesOrder[nextIndex];\n    return typeof shiftedType === 'number' ? shiftedType : type;\n  };\n\n  return InternalDateMediator;\n}();"]},"metadata":{},"sourceType":"module"}