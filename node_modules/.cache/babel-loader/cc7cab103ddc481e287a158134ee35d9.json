{"ast":null,"code":"import tabbable from 'tabbable';\n/**\r\n                                  * Поиск всех фокусируемых элементов в переданном родителе\r\n                                  * или на всей странице\r\n                                  * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n                                  * внутри которого осуществляется поиск.\r\n                                  * @return {HTMLElement[]} - Массив найденных элементов\r\n                                  */\n\nexport var getFocusableElements = function getFocusableElements(parent) {\n  if (parent === void 0) {\n    parent = document;\n  }\n\n  if (!parent || !parent.children.length) {\n    return [];\n  }\n\n  return tabbable(parent);\n};\n/**\r\n    * Поиск первого фокусируемого элемента в переданном родителе\r\n    * или на всей странице\r\n    * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n    * внутри которого осуществляется поиск.\r\n    * @return {HTMLElement|null} - Найденный элемент или null\r\n    */\n\nexport var getFirstFocusableElement = function getFirstFocusableElement(parent) {\n  if (parent === void 0) {\n    parent = document;\n  }\n\n  if (!parent || !parent.children.length) {\n    return null;\n  }\n\n  return getFocusableElements(parent)[0] || null;\n};\n/**\r\n    * Поиск следующего фокусируемого элемента в переданном родителе\r\n    * или на всей странице\r\n    * @param {HTMLElement} current - Текущий фокусируемый элемент\r\n    * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n    * внутри которого осуществляется поиск.\r\n    * @param {boolean} [recursive=true] - Разрешает рекурсивный подъем вверх\r\n    * по родителям\r\n    * @return {HTMLElement|null} - Найденный элемент или null\r\n    *\r\n    * В случае поиска по всей странице, можно оставить parent === document,\r\n    * тогда результат будет максимально точным, но возможны задержки\r\n    * при большом кол-ве фокусируемых элементов на странице.\r\n    * Если же передать parent === current.parentElement и recursive === true,\r\n    * то поиск осуществится максимально быстро. Но может оказаться не учтенным\r\n    * порядок элементов с [tabindex] > 0.\r\n    */\n\nexport var getNextFocusableElement = function getNextFocusableElement(current, parent, recursive) {\n  if (parent === void 0) {\n    parent = document;\n  }\n\n  if (recursive === void 0) {\n    recursive = true;\n  }\n\n  if (!parent || !parent.contains(current)) {\n    return null;\n  }\n\n  if (parent.lastElementChild !== current) {\n    var tabbables = getFocusableElements(parent);\n\n    if (tabbables.length > 1) {\n      var currentIndex = tabbables.indexOf(current);\n      var lastIndex = tabbables.length - 1;\n\n      if (currentIndex === -1) {\n        return null;\n      }\n\n      if (currentIndex < lastIndex) {\n        return tabbables[currentIndex + 1];\n      }\n    }\n  }\n\n  return recursive ? getNextFocusableElement(current, parent.parentElement) : null;\n};\n/**\r\n    * Поиск ближайшего фокусируемого элемента среди переданного и его родителей\r\n    * @param {HTMLElement} current - Текущий элемент\r\n    * @return {HTMLElement|null} - Найденный элемент или null\r\n    *\r\n    */\n\nexport var getClosestFocusableElement = function getClosestFocusableElement(current) {\n  if (!current) {\n    return null;\n  }\n\n  return tabbable.isFocusable(current) ? current : getClosestFocusableElement(current.parentElement);\n};","map":{"version":3,"sources":["C:/Users/ravka/Desktop/react-typescript-task/node_modules/@skbkontur/react-ui/lib/dom/getFocusableElements/getFocusableElements.js"],"names":["tabbable","getFocusableElements","parent","document","children","length","getFirstFocusableElement","getNextFocusableElement","current","recursive","contains","lastElementChild","tabbables","currentIndex","indexOf","lastIndex","parentElement","getClosestFocusableElement","isFocusable"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;AACA;;;;;;;;AAQA,OAAO,IAAIC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,MAA9B,EAAsC;AACtE,MAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrBA,IAAAA,MAAM,GAAGC,QAAT;AACD;;AAED,MAAI,CAACD,MAAD,IAAW,CAACA,MAAM,CAACE,QAAP,CAAgBC,MAAhC,EAAwC;AACtC,WAAO,EAAP;AACD;;AAED,SAAOL,QAAQ,CAACE,MAAD,CAAf;AACD,CAVM;AAWP;;;;;;;;AAQA,OAAO,IAAII,wBAAwB,GAAG,SAASA,wBAAT,CAAkCJ,MAAlC,EAA0C;AAC9E,MAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrBA,IAAAA,MAAM,GAAGC,QAAT;AACD;;AAED,MAAI,CAACD,MAAD,IAAW,CAACA,MAAM,CAACE,QAAP,CAAgBC,MAAhC,EAAwC;AACtC,WAAO,IAAP;AACD;;AAED,SAAOJ,oBAAoB,CAACC,MAAD,CAApB,CAA6B,CAA7B,KAAmC,IAA1C;AACD,CAVM;AAWP;;;;;;;;;;;;;;;;;;AAkBA,OAAO,IAAIK,uBAAuB,GAAG,SAASA,uBAAT,CAAiCC,OAAjC,EAA0CN,MAA1C,EAAkDO,SAAlD,EAA6D;AAChG,MAAIP,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrBA,IAAAA,MAAM,GAAGC,QAAT;AACD;;AAED,MAAIM,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxBA,IAAAA,SAAS,GAAG,IAAZ;AACD;;AAED,MAAI,CAACP,MAAD,IAAW,CAACA,MAAM,CAACQ,QAAP,CAAgBF,OAAhB,CAAhB,EAA0C;AACxC,WAAO,IAAP;AACD;;AAED,MAAIN,MAAM,CAACS,gBAAP,KAA4BH,OAAhC,EAAyC;AACvC,QAAII,SAAS,GAAGX,oBAAoB,CAACC,MAAD,CAApC;;AAEA,QAAIU,SAAS,CAACP,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAIQ,YAAY,GAAGD,SAAS,CAACE,OAAV,CAAkBN,OAAlB,CAAnB;AACA,UAAIO,SAAS,GAAGH,SAAS,CAACP,MAAV,GAAmB,CAAnC;;AAEA,UAAIQ,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB,eAAO,IAAP;AACD;;AAED,UAAIA,YAAY,GAAGE,SAAnB,EAA8B;AAC5B,eAAOH,SAAS,CAACC,YAAY,GAAG,CAAhB,CAAhB;AACD;AACF;AACF;;AAED,SAAOJ,SAAS,GAAGF,uBAAuB,CAACC,OAAD,EAAUN,MAAM,CAACc,aAAjB,CAA1B,GAA4D,IAA5E;AACD,CA/BM;AAgCP;;;;;;;AAOA,OAAO,IAAIC,0BAA0B,GAAG,SAASA,0BAAT,CAAoCT,OAApC,EAA6C;AACnF,MAAI,CAACA,OAAL,EAAc;AACZ,WAAO,IAAP;AACD;;AAED,SAAOR,QAAQ,CAACkB,WAAT,CAAqBV,OAArB,IAAgCA,OAAhC,GAA0CS,0BAA0B,CAACT,OAAO,CAACQ,aAAT,CAA3E;AACD,CANM","sourcesContent":["import tabbable from 'tabbable';\n/**\r\n                                  * Поиск всех фокусируемых элементов в переданном родителе\r\n                                  * или на всей странице\r\n                                  * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n                                  * внутри которого осуществляется поиск.\r\n                                  * @return {HTMLElement[]} - Массив найденных элементов\r\n                                  */\n\nexport var getFocusableElements = function getFocusableElements(parent) {\n  if (parent === void 0) {\n    parent = document;\n  }\n\n  if (!parent || !parent.children.length) {\n    return [];\n  }\n\n  return tabbable(parent);\n};\n/**\r\n    * Поиск первого фокусируемого элемента в переданном родителе\r\n    * или на всей странице\r\n    * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n    * внутри которого осуществляется поиск.\r\n    * @return {HTMLElement|null} - Найденный элемент или null\r\n    */\n\nexport var getFirstFocusableElement = function getFirstFocusableElement(parent) {\n  if (parent === void 0) {\n    parent = document;\n  }\n\n  if (!parent || !parent.children.length) {\n    return null;\n  }\n\n  return getFocusableElements(parent)[0] || null;\n};\n/**\r\n    * Поиск следующего фокусируемого элемента в переданном родителе\r\n    * или на всей странице\r\n    * @param {HTMLElement} current - Текущий фокусируемый элемент\r\n    * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n    * внутри которого осуществляется поиск.\r\n    * @param {boolean} [recursive=true] - Разрешает рекурсивный подъем вверх\r\n    * по родителям\r\n    * @return {HTMLElement|null} - Найденный элемент или null\r\n    *\r\n    * В случае поиска по всей странице, можно оставить parent === document,\r\n    * тогда результат будет максимально точным, но возможны задержки\r\n    * при большом кол-ве фокусируемых элементов на странице.\r\n    * Если же передать parent === current.parentElement и recursive === true,\r\n    * то поиск осуществится максимально быстро. Но может оказаться не учтенным\r\n    * порядок элементов с [tabindex] > 0.\r\n    */\n\nexport var getNextFocusableElement = function getNextFocusableElement(current, parent, recursive) {\n  if (parent === void 0) {\n    parent = document;\n  }\n\n  if (recursive === void 0) {\n    recursive = true;\n  }\n\n  if (!parent || !parent.contains(current)) {\n    return null;\n  }\n\n  if (parent.lastElementChild !== current) {\n    var tabbables = getFocusableElements(parent);\n\n    if (tabbables.length > 1) {\n      var currentIndex = tabbables.indexOf(current);\n      var lastIndex = tabbables.length - 1;\n\n      if (currentIndex === -1) {\n        return null;\n      }\n\n      if (currentIndex < lastIndex) {\n        return tabbables[currentIndex + 1];\n      }\n    }\n  }\n\n  return recursive ? getNextFocusableElement(current, parent.parentElement) : null;\n};\n/**\r\n    * Поиск ближайшего фокусируемого элемента среди переданного и его родителей\r\n    * @param {HTMLElement} current - Текущий элемент\r\n    * @return {HTMLElement|null} - Найденный элемент или null\r\n    *\r\n    */\n\nexport var getClosestFocusableElement = function getClosestFocusableElement(current) {\n  if (!current) {\n    return null;\n  }\n\n  return tabbable.isFocusable(current) ? current : getClosestFocusableElement(current.parentElement);\n};"]},"metadata":{},"sourceType":"module"}