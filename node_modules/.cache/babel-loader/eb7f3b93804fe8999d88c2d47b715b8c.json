{"ast":null,"code":"export function clamp(val, max) {\n  if (max === void 0) {\n    max = 1;\n  }\n\n  return Math.min(max, Math.max(0, val));\n}\nexport function integerFromPercent(n, size) {\n  return Math.round(parseFloat(n) * size / 100);\n}\nexport function floatFromPercent(n) {\n  return parseFloat((parseFloat(n) / 100).toFixed(5));\n}\nexport function roundToPrecision(n, precision) {\n  if (precision === void 0) {\n    precision = 2;\n  }\n\n  return parseFloat(n.toFixed(precision));\n}\nexport function extractColorParts(input, solidRegex, alphaRegex) {\n  var parts = solidRegex.exec(input);\n\n  if (!parts && alphaRegex) {\n    parts = alphaRegex.exec(input);\n  }\n\n  if (!parts) {\n    throw new Error(input + \" does not match color patterns: [\\n      \" + solidRegex + \"\\n      \" + alphaRegex + \"\\n    ]\");\n  }\n\n  return parts;\n}\nexport function parseRGBParts(parts) {\n  var r = parseToInteger(parts[1], 255);\n  var g = parseToInteger(parts[2], 255);\n  var b = parseToInteger(parts[3], 255);\n  var a = parts[4] ? parseToFloat(parts[4]) : 1.0;\n\n  if (isNaN(r)) {\n    throw new Error(\"Could not parse red=\" + parts[1] + \" to number\");\n  }\n\n  if (isNaN(g)) {\n    throw new Error(\"Could not parse green=\" + parts[2] + \" to number\");\n  }\n\n  if (isNaN(b)) {\n    throw new Error(\"Could not parse blue=\" + parts[3] + \" to number\");\n  }\n\n  if (isNaN(a)) {\n    throw new Error(\"Could not parse alpha=\" + parts[4] + \" to number\");\n  }\n\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nexport function parseHSLParts(parts) {\n  var h = parseInt(parts[1], 10);\n  var s = parseToFloat(parts[2]);\n  var l = parseToFloat(parts[3]);\n  var a = parts[4] ? parseToFloat(parts[4]) : 1.0;\n\n  if (isNaN(h)) {\n    throw new Error(\"Could not parse hue=\" + parts[1] + \" to number\");\n  } else if (isNaN(s)) {\n    throw new Error(\"Could not parse saturation=\" + parts[2] + \" to number\");\n  } else if (isNaN(l)) {\n    throw new Error(\"Could not parse lightness=\" + parts[3] + \" to number\");\n  } else if (isNaN(a)) {\n    throw new Error(\"Could not parse alpha=\" + parts[4] + \" to number\");\n  }\n\n  return {\n    h: h,\n    s: s,\n    l: l,\n    a: a\n  };\n}\nexport function parseToInteger(part, size) {\n  return part.endsWith('%') ? integerFromPercent(part, size) : parseInt(part, 10);\n}\nexport function parseToFloat(part) {\n  return part.endsWith('%') ? floatFromPercent(part) : parseFloat(part);\n}\nexport function hue2rgb(hue, t1, t2) {\n  if (hue < 0) {\n    hue += 1;\n  }\n\n  if (hue > 1) {\n    hue -= 1;\n  }\n\n  if (hue < 1 / 6) {\n    return t2 + (t1 - t2) * 6 * hue;\n  }\n\n  if (hue < 1 / 2) {\n    return t1;\n  }\n\n  if (hue < 2 / 3) {\n    return t2 + (t1 - t2) * (2 / 3 - hue) * 6;\n  }\n\n  return t2;\n}","map":{"version":3,"sources":["C:/Users/ravka/Desktop/react-typescript-task/node_modules/@skbkontur/react-ui/lib/styles/ColorHelpers/ColorHelpers.js"],"names":["clamp","val","max","Math","min","integerFromPercent","n","size","round","parseFloat","floatFromPercent","toFixed","roundToPrecision","precision","extractColorParts","input","solidRegex","alphaRegex","parts","exec","Error","parseRGBParts","r","parseToInteger","g","b","a","parseToFloat","isNaN","parseHSLParts","h","parseInt","s","l","part","endsWith","hue2rgb","hue","t1","t2"],"mappings":"AAAA,OAAO,SAASA,KAAT,CAAeC,GAAf,EAAoBC,GAApB,EAAyB;AAC9B,MAAIA,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAClBA,IAAAA,GAAG,GAAG,CAAN;AACD;;AAED,SAAOC,IAAI,CAACC,GAAL,CAASF,GAAT,EAAcC,IAAI,CAACD,GAAL,CAAS,CAAT,EAAYD,GAAZ,CAAd,CAAP;AACD;AACD,OAAO,SAASI,kBAAT,CAA4BC,CAA5B,EAA+BC,IAA/B,EAAqC;AAC1C,SAAOJ,IAAI,CAACK,KAAL,CAAWC,UAAU,CAACH,CAAD,CAAV,GAAgBC,IAAhB,GAAuB,GAAlC,CAAP;AACD;AACD,OAAO,SAASG,gBAAT,CAA0BJ,CAA1B,EAA6B;AAClC,SAAOG,UAAU,CAAC,CAACA,UAAU,CAACH,CAAD,CAAV,GAAgB,GAAjB,EAAsBK,OAAtB,CAA8B,CAA9B,CAAD,CAAjB;AACD;AACD,OAAO,SAASC,gBAAT,CAA0BN,CAA1B,EAA6BO,SAA7B,EAAwC;AAC7C,MAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxBA,IAAAA,SAAS,GAAG,CAAZ;AACD;;AAED,SAAOJ,UAAU,CAACH,CAAC,CAACK,OAAF,CAAUE,SAAV,CAAD,CAAjB;AACD;AACD,OAAO,SAASC,iBAAT,CAA2BC,KAA3B,EAAkCC,UAAlC,EAA8CC,UAA9C,EAA0D;AAC/D,MAAIC,KAAK,GAAGF,UAAU,CAACG,IAAX,CAAgBJ,KAAhB,CAAZ;;AAEA,MAAI,CAACG,KAAD,IAAUD,UAAd,EAA0B;AACxBC,IAAAA,KAAK,GAAGD,UAAU,CAACE,IAAX,CAAgBJ,KAAhB,CAAR;AACD;;AAED,MAAI,CAACG,KAAL,EAAY;AACV,UAAM,IAAIE,KAAJ,CAAUL,KAAK,GAAG,2CAAR,GAAsDC,UAAtD,GAAmE,UAAnE,GAAgFC,UAAhF,GAA6F,SAAvG,CAAN;AACD;;AAED,SAAOC,KAAP;AACD;AACD,OAAO,SAASG,aAAT,CAAuBH,KAAvB,EAA8B;AACnC,MAAII,CAAC,GAAGC,cAAc,CAACL,KAAK,CAAC,CAAD,CAAN,EAAW,GAAX,CAAtB;AACA,MAAIM,CAAC,GAAGD,cAAc,CAACL,KAAK,CAAC,CAAD,CAAN,EAAW,GAAX,CAAtB;AACA,MAAIO,CAAC,GAAGF,cAAc,CAACL,KAAK,CAAC,CAAD,CAAN,EAAW,GAAX,CAAtB;AACA,MAAIQ,CAAC,GAAGR,KAAK,CAAC,CAAD,CAAL,GAAWS,YAAY,CAACT,KAAK,CAAC,CAAD,CAAN,CAAvB,GAAoC,GAA5C;;AAEA,MAAIU,KAAK,CAACN,CAAD,CAAT,EAAc;AACZ,UAAM,IAAIF,KAAJ,CAAU,yBAAyBF,KAAK,CAAC,CAAD,CAA9B,GAAoC,YAA9C,CAAN;AACD;;AAED,MAAIU,KAAK,CAACJ,CAAD,CAAT,EAAc;AACZ,UAAM,IAAIJ,KAAJ,CAAU,2BAA2BF,KAAK,CAAC,CAAD,CAAhC,GAAsC,YAAhD,CAAN;AACD;;AAED,MAAIU,KAAK,CAACH,CAAD,CAAT,EAAc;AACZ,UAAM,IAAIL,KAAJ,CAAU,0BAA0BF,KAAK,CAAC,CAAD,CAA/B,GAAqC,YAA/C,CAAN;AACD;;AAED,MAAIU,KAAK,CAACF,CAAD,CAAT,EAAc;AACZ,UAAM,IAAIN,KAAJ,CAAU,2BAA2BF,KAAK,CAAC,CAAD,CAAhC,GAAsC,YAAhD,CAAN;AACD;;AAED,SAAO;AACLI,IAAAA,CAAC,EAAEA,CADE;AAELE,IAAAA,CAAC,EAAEA,CAFE;AAGLC,IAAAA,CAAC,EAAEA,CAHE;AAILC,IAAAA,CAAC,EAAEA;AAJE,GAAP;AAMD;AACD,OAAO,SAASG,aAAT,CAAuBX,KAAvB,EAA8B;AACnC,MAAIY,CAAC,GAAGC,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAhB;AACA,MAAIc,CAAC,GAAGL,YAAY,CAACT,KAAK,CAAC,CAAD,CAAN,CAApB;AACA,MAAIe,CAAC,GAAGN,YAAY,CAACT,KAAK,CAAC,CAAD,CAAN,CAApB;AACA,MAAIQ,CAAC,GAAGR,KAAK,CAAC,CAAD,CAAL,GAAWS,YAAY,CAACT,KAAK,CAAC,CAAD,CAAN,CAAvB,GAAoC,GAA5C;;AAEA,MAAIU,KAAK,CAACE,CAAD,CAAT,EAAc;AACZ,UAAM,IAAIV,KAAJ,CAAU,yBAAyBF,KAAK,CAAC,CAAD,CAA9B,GAAoC,YAA9C,CAAN;AACD,GAFD,MAEO,IAAIU,KAAK,CAACI,CAAD,CAAT,EAAc;AACnB,UAAM,IAAIZ,KAAJ,CAAU,gCAAgCF,KAAK,CAAC,CAAD,CAArC,GAA2C,YAArD,CAAN;AACD,GAFM,MAEA,IAAIU,KAAK,CAACK,CAAD,CAAT,EAAc;AACnB,UAAM,IAAIb,KAAJ,CAAU,+BAA+BF,KAAK,CAAC,CAAD,CAApC,GAA0C,YAApD,CAAN;AACD,GAFM,MAEA,IAAIU,KAAK,CAACF,CAAD,CAAT,EAAc;AACnB,UAAM,IAAIN,KAAJ,CAAU,2BAA2BF,KAAK,CAAC,CAAD,CAAhC,GAAsC,YAAhD,CAAN;AACD;;AAED,SAAO;AACLY,IAAAA,CAAC,EAAEA,CADE;AAELE,IAAAA,CAAC,EAAEA,CAFE;AAGLC,IAAAA,CAAC,EAAEA,CAHE;AAILP,IAAAA,CAAC,EAAEA;AAJE,GAAP;AAMD;AACD,OAAO,SAASH,cAAT,CAAwBW,IAAxB,EAA8B3B,IAA9B,EAAoC;AACzC,SAAO2B,IAAI,CAACC,QAAL,CAAc,GAAd,IAAqB9B,kBAAkB,CAAC6B,IAAD,EAAO3B,IAAP,CAAvC,GAAsDwB,QAAQ,CAACG,IAAD,EAAO,EAAP,CAArE;AACD;AACD,OAAO,SAASP,YAAT,CAAsBO,IAAtB,EAA4B;AACjC,SAAOA,IAAI,CAACC,QAAL,CAAc,GAAd,IAAqBzB,gBAAgB,CAACwB,IAAD,CAArC,GAA8CzB,UAAU,CAACyB,IAAD,CAA/D;AACD;AACD,OAAO,SAASE,OAAT,CAAiBC,GAAjB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8B;AACnC,MAAIF,GAAG,GAAG,CAAV,EAAa;AACXA,IAAAA,GAAG,IAAI,CAAP;AACD;;AAED,MAAIA,GAAG,GAAG,CAAV,EAAa;AACXA,IAAAA,GAAG,IAAI,CAAP;AACD;;AAED,MAAIA,GAAG,GAAG,IAAI,CAAd,EAAiB;AACf,WAAOE,EAAE,GAAG,CAACD,EAAE,GAAGC,EAAN,IAAY,CAAZ,GAAgBF,GAA5B;AACD;;AAED,MAAIA,GAAG,GAAG,IAAI,CAAd,EAAiB;AACf,WAAOC,EAAP;AACD;;AAED,MAAID,GAAG,GAAG,IAAI,CAAd,EAAiB;AACf,WAAOE,EAAE,GAAG,CAACD,EAAE,GAAGC,EAAN,KAAa,IAAI,CAAJ,GAAQF,GAArB,IAA4B,CAAxC;AACD;;AAED,SAAOE,EAAP;AACD","sourcesContent":["export function clamp(val, max) {\n  if (max === void 0) {\n    max = 1;\n  }\n\n  return Math.min(max, Math.max(0, val));\n}\nexport function integerFromPercent(n, size) {\n  return Math.round(parseFloat(n) * size / 100);\n}\nexport function floatFromPercent(n) {\n  return parseFloat((parseFloat(n) / 100).toFixed(5));\n}\nexport function roundToPrecision(n, precision) {\n  if (precision === void 0) {\n    precision = 2;\n  }\n\n  return parseFloat(n.toFixed(precision));\n}\nexport function extractColorParts(input, solidRegex, alphaRegex) {\n  var parts = solidRegex.exec(input);\n\n  if (!parts && alphaRegex) {\n    parts = alphaRegex.exec(input);\n  }\n\n  if (!parts) {\n    throw new Error(input + \" does not match color patterns: [\\n      \" + solidRegex + \"\\n      \" + alphaRegex + \"\\n    ]\");\n  }\n\n  return parts;\n}\nexport function parseRGBParts(parts) {\n  var r = parseToInteger(parts[1], 255);\n  var g = parseToInteger(parts[2], 255);\n  var b = parseToInteger(parts[3], 255);\n  var a = parts[4] ? parseToFloat(parts[4]) : 1.0;\n\n  if (isNaN(r)) {\n    throw new Error(\"Could not parse red=\" + parts[1] + \" to number\");\n  }\n\n  if (isNaN(g)) {\n    throw new Error(\"Could not parse green=\" + parts[2] + \" to number\");\n  }\n\n  if (isNaN(b)) {\n    throw new Error(\"Could not parse blue=\" + parts[3] + \" to number\");\n  }\n\n  if (isNaN(a)) {\n    throw new Error(\"Could not parse alpha=\" + parts[4] + \" to number\");\n  }\n\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nexport function parseHSLParts(parts) {\n  var h = parseInt(parts[1], 10);\n  var s = parseToFloat(parts[2]);\n  var l = parseToFloat(parts[3]);\n  var a = parts[4] ? parseToFloat(parts[4]) : 1.0;\n\n  if (isNaN(h)) {\n    throw new Error(\"Could not parse hue=\" + parts[1] + \" to number\");\n  } else if (isNaN(s)) {\n    throw new Error(\"Could not parse saturation=\" + parts[2] + \" to number\");\n  } else if (isNaN(l)) {\n    throw new Error(\"Could not parse lightness=\" + parts[3] + \" to number\");\n  } else if (isNaN(a)) {\n    throw new Error(\"Could not parse alpha=\" + parts[4] + \" to number\");\n  }\n\n  return {\n    h: h,\n    s: s,\n    l: l,\n    a: a\n  };\n}\nexport function parseToInteger(part, size) {\n  return part.endsWith('%') ? integerFromPercent(part, size) : parseInt(part, 10);\n}\nexport function parseToFloat(part) {\n  return part.endsWith('%') ? floatFromPercent(part) : parseFloat(part);\n}\nexport function hue2rgb(hue, t1, t2) {\n  if (hue < 0) {\n    hue += 1;\n  }\n\n  if (hue > 1) {\n    hue -= 1;\n  }\n\n  if (hue < 1 / 6) {\n    return t2 + (t1 - t2) * 6 * hue;\n  }\n\n  if (hue < 1 / 2) {\n    return t1;\n  }\n\n  if (hue < 2 / 3) {\n    return t2 + (t1 - t2) * (2 / 3 - hue) * 6;\n  }\n\n  return t2;\n}"]},"metadata":{},"sourceType":"module"}