import warning from 'warning';
import { clamp, extractColorParts, hue2rgb, parseHSLParts, parseRGBParts } from "../ColorHelpers";
import { ColorKeywords } from "../ColorKeywords";
import { ColorObject } from "../ColorObject";
var RGB_REGEX = /rgb\(\s*(\d{1,3}(?:(?:\.\d+)?%)?)\s*,\s*(\d{1,3}(?:(?:\.\d+)?%)?)\s*,\s*(\d{1,3}(?:(?:\.\d+)?%)?)\s*\)/;
var RGBA_REGEX = /rgba\(\s*(\d{1,3}(?:(?:\.\d+)?%)?)\s*,\s*(\d{1,3}(?:(?:\.\d+)?%)?)\s*,\s*(\d{1,3}(?:(?:\.\d+)?%)?)\s*,\s*(0|0\.\d+|1|1\.0+|\d{1,3}(?:(?:\.\d+)?%))\s*\)/;
var HSL_REGEX = /hsl\(\s*(\d{1,3})\s*,\s*(0|0\.\d+|1|1\.0+|\d{1,3}(?:(?:\.\d+)?%))\s*,\s*(0|0\.\d+|1|1\.0+|\d{1,3}(?:(?:\.\d+)?%))\s*\)/;
var HSLA_REGEX = /hsla\(\s*(\d{1,3})\s*,\s*(0|0\.\d+|1|1\.0+|\d{1,3}(?:(?:\.\d+)?%))\s*,\s*(0|0\.\d+|1|1\.0+|\d{1,3}(?:(?:\.\d+)?%))\s*,\s*(0|0\.\d+|1|1\.0+|\d{1,3}(?:(?:\.\d+)?%))\s*\)/;
var HEX_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{6})$/;
export var ColorFactory =
/*#__PURE__*/
function () {
  function ColorFactory() {}

  ColorFactory.create = function create(input) {
    if (!this.cache[input]) {
      this.cache[input] = this.instantiate(input);
    }

    return this.cache[input];
  };

  ColorFactory.instantiate = function instantiate(input) {
    if (typeof input !== 'string') {
      warning(false, "Invalid type of input (" + typeof input + "), expected a string. Returning transparent color");
      return new ColorObject([0, 0, 0], 1.0, 'transparent');
    }

    input = input.toLowerCase().trim();

    if (input === 'transparent') {
      return new ColorObject([0, 0, 0], 0, 'transparent');
    } else if (this.isKeyword(input)) {
      return this.fromKeyword(input);
    } else if (input.startsWith('rgb')) {
      var parts = extractColorParts(input, RGB_REGEX, RGBA_REGEX);

      var _parseRGBParts = parseRGBParts(parts),
          r = _parseRGBParts.r,
          g = _parseRGBParts.g,
          b = _parseRGBParts.b,
          a = _parseRGBParts.a;

      r = clamp(r, 255);
      g = clamp(g, 255);
      b = clamp(b, 255);
      a = clamp(a, 1);
      return this.fromRGB(r, g, b, a);
    } else if (input.startsWith('hsl')) {
      var _parts = extractColorParts(input, HSL_REGEX, HSLA_REGEX);

      var _parseHSLParts = parseHSLParts(_parts),
          h = _parseHSLParts.h,
          s = _parseHSLParts.s,
          l = _parseHSLParts.l,
          _a = _parseHSLParts.a;

      h = clamp(h, 360);
      s = clamp(s, 1);
      l = clamp(l, 1);
      _a = clamp(_a, 1);
      return this.fromHSL(h, s, l, _a);
    }

    return this.fromHex(input);
  };

  ColorFactory.isKeyword = function isKeyword(input) {
    return Object.prototype.hasOwnProperty.call(ColorKeywords, input);
  };

  ColorFactory.fromKeyword = function fromKeyword(keyword) {
    return this.fromHex(ColorKeywords[keyword], keyword);
  };

  ColorFactory.fromHex = function fromHex(hexString, type) {
    if (type === void 0) {
      type = 'hex';
    }

    if (!HEX_REGEX.test(hexString)) {
      throw new Error(hexString + " is not a valid hex color string");
    }

    var colorCode = hexString.substring(1);
    var rgb = [0, 0, 0];

    if (colorCode.length === 6) {
      colorCode.match(/.{2}/g).forEach(function (c, i) {
        rgb[i] = parseInt(c, 16);
      });
    } else if (colorCode.length === 3) {
      colorCode.split('').forEach(function (c, i) {
        rgb[i] = parseInt(c + c, 16);
      });
    }

    return new ColorObject(rgb, 1.0, type);
  };

  ColorFactory.fromRGB = function fromRGB(r, g, b, a) {
    if (a === void 0) {
      a = 1.0;
    }

    return new ColorObject([r, g, b], a, a < 1 ? 'rgba' : 'rgb');
  };

  ColorFactory.fromHSL = function fromHSL(h, s, l, a) {
    if (a === void 0) {
      a = 1.0;
    }

    if (s === 0) {
      var gray = Math.round(l * 255);
      return new ColorObject([gray, gray, gray], a, a < 1 ? 'hsla' : 'hsl');
    }

    var hDeg = h / 360;
    var t1 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var t2 = l * 2 - t1;
    var r = hue2rgb(hDeg + 1 / 3, t1, t2);
    var g = hue2rgb(hDeg, t1, t2);
    var b = hue2rgb(hDeg - 1 / 3, t1, t2);
    var rgb = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    return new ColorObject(rgb, a, a < 1 ? 'hsla' : 'hsl');
  };

  return ColorFactory;
}();
ColorFactory.cache = Object.create(null);