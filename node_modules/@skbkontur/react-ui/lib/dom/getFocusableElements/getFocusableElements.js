import tabbable from 'tabbable';
/**
                                  * Поиск всех фокусируемых элементов в переданном родителе
                                  * или на всей странице
                                  * @param {Element|Document|null} [parent=document] - Родительский элемент,
                                  * внутри которого осуществляется поиск.
                                  * @return {HTMLElement[]} - Массив найденных элементов
                                  */

export var getFocusableElements = function getFocusableElements(parent) {
  if (parent === void 0) {
    parent = document;
  }

  if (!parent || !parent.children.length) {
    return [];
  }

  return tabbable(parent);
};
/**
    * Поиск первого фокусируемого элемента в переданном родителе
    * или на всей странице
    * @param {Element|Document|null} [parent=document] - Родительский элемент,
    * внутри которого осуществляется поиск.
    * @return {HTMLElement|null} - Найденный элемент или null
    */

export var getFirstFocusableElement = function getFirstFocusableElement(parent) {
  if (parent === void 0) {
    parent = document;
  }

  if (!parent || !parent.children.length) {
    return null;
  }

  return getFocusableElements(parent)[0] || null;
};
/**
    * Поиск следующего фокусируемого элемента в переданном родителе
    * или на всей странице
    * @param {HTMLElement} current - Текущий фокусируемый элемент
    * @param {Element|Document|null} [parent=document] - Родительский элемент,
    * внутри которого осуществляется поиск.
    * @param {boolean} [recursive=true] - Разрешает рекурсивный подъем вверх
    * по родителям
    * @return {HTMLElement|null} - Найденный элемент или null
    *
    * В случае поиска по всей странице, можно оставить parent === document,
    * тогда результат будет максимально точным, но возможны задержки
    * при большом кол-ве фокусируемых элементов на странице.
    * Если же передать parent === current.parentElement и recursive === true,
    * то поиск осуществится максимально быстро. Но может оказаться не учтенным
    * порядок элементов с [tabindex] > 0.
    */

export var getNextFocusableElement = function getNextFocusableElement(current, parent, recursive) {
  if (parent === void 0) {
    parent = document;
  }

  if (recursive === void 0) {
    recursive = true;
  }

  if (!parent || !parent.contains(current)) {
    return null;
  }

  if (parent.lastElementChild !== current) {
    var tabbables = getFocusableElements(parent);

    if (tabbables.length > 1) {
      var currentIndex = tabbables.indexOf(current);
      var lastIndex = tabbables.length - 1;

      if (currentIndex === -1) {
        return null;
      }

      if (currentIndex < lastIndex) {
        return tabbables[currentIndex + 1];
      }
    }
  }

  return recursive ? getNextFocusableElement(current, parent.parentElement) : null;
};
/**
    * Поиск ближайшего фокусируемого элемента среди переданного и его родителей
    * @param {HTMLElement} current - Текущий элемент
    * @return {HTMLElement|null} - Найденный элемент или null
    *
    */

export var getClosestFocusableElement = function getClosestFocusableElement(current) {
  if (!current) {
    return null;
  }

  return tabbable.isFocusable(current) ? current : getClosestFocusableElement(current.parentElement);
};