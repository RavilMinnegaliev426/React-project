{"version":3,"sources":["getFocusableElements.ts"],"names":["tabbable","getFocusableElements","parent","document","children","length","getFirstFocusableElement","getNextFocusableElement","current","recursive","contains","lastElementChild","tabbables","currentIndex","indexOf","lastIndex","parentElement","getClosestFocusableElement","isFocusable"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;;AAEA;;;;;;;;AAQA,OAAO,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,MAAD,EAAiE,KAAhEA,MAAgE,cAAhEA,MAAgE,GAA5BC,QAA4B;AACnG,MAAI,CAACD,MAAD,IAAW,CAACA,MAAM,CAACE,QAAP,CAAgBC,MAAhC,EAAwC;AACtC,WAAO,EAAP;AACD;AACD,SAAOL,QAAQ,CAACE,MAAD,CAAf;AACD,CALM;;AAOP;;;;;;;;AAQA,OAAO,IAAMI,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACJ,MAAD,EAAsE,KAArEA,MAAqE,cAArEA,MAAqE,GAAjCC,QAAiC;AAC5G,MAAI,CAACD,MAAD,IAAW,CAACA,MAAM,CAACE,QAAP,CAAgBC,MAAhC,EAAwC;AACtC,WAAO,IAAP;AACD;AACD,SAAOJ,oBAAoB,CAACC,MAAD,CAApB,CAA6B,CAA7B,KAAmC,IAA1C;AACD,CALM;;AAOP;;;;;;;;;;;;;;;;;;AAkBA,OAAO,IAAMK,uBAAuB,GAAG,SAA1BA,uBAA0B;AACrCC,OADqC;AAErCN,MAFqC;AAGrCO,SAHqC;AAId,KAFvBP,MAEuB,cAFvBA,MAEuB,GAFaC,QAEb,MADvBM,SACuB,cADvBA,SACuB,GADX,IACW;AACvB,MAAI,CAACP,MAAD,IAAW,CAACA,MAAM,CAACQ,QAAP,CAAgBF,OAAhB,CAAhB,EAA0C;AACxC,WAAO,IAAP;AACD;AACD,MAAIN,MAAM,CAACS,gBAAP,KAA4BH,OAAhC,EAAyC;AACvC,QAAMI,SAAS,GAAGX,oBAAoB,CAACC,MAAD,CAAtC;AACA,QAAIU,SAAS,CAACP,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAMQ,YAAY,GAAGD,SAAS,CAACE,OAAV,CAAkBN,OAAlB,CAArB;AACA,UAAMO,SAAS,GAAGH,SAAS,CAACP,MAAV,GAAmB,CAArC;AACA,UAAIQ,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB,eAAO,IAAP;AACD;AACD,UAAIA,YAAY,GAAGE,SAAnB,EAA8B;AAC5B,eAAOH,SAAS,CAACC,YAAY,GAAG,CAAhB,CAAhB;AACD;AACF;AACF;AACD,SAAOJ,SAAS,GAAGF,uBAAuB,CAACC,OAAD,EAAUN,MAAM,CAACc,aAAjB,CAA1B,GAA4D,IAA5E;AACD,CAtBM;;AAwBP;;;;;;;AAOA,OAAO,IAAMC,0BAA0B,GAAG,SAA7BA,0BAA6B,CAACT,OAAD,EAAqD;AAC7F,MAAI,CAACA,OAAL,EAAc;AACZ,WAAO,IAAP;AACD;;AAED,SAAOR,QAAQ,CAACkB,WAAT,CAAqBV,OAArB,IAAgCA,OAAhC,GAA0CS,0BAA0B,CAACT,OAAO,CAACQ,aAAT,CAA3E;AACD,CANM","sourcesContent":["import tabbable from 'tabbable';\r\n\r\n/**\r\n * Поиск всех фокусируемых элементов в переданном родителе\r\n * или на всей странице\r\n * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n * внутри которого осуществляется поиск.\r\n * @return {HTMLElement[]} - Массив найденных элементов\r\n */\r\n\r\nexport const getFocusableElements = (parent: Element | Document | null = document): HTMLElement[] => {\r\n  if (!parent || !parent.children.length) {\r\n    return [];\r\n  }\r\n  return tabbable(parent);\r\n};\r\n\r\n/**\r\n * Поиск первого фокусируемого элемента в переданном родителе\r\n * или на всей странице\r\n * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n * внутри которого осуществляется поиск.\r\n * @return {HTMLElement|null} - Найденный элемент или null\r\n */\r\n\r\nexport const getFirstFocusableElement = (parent: Element | Document | null = document): HTMLElement | null => {\r\n  if (!parent || !parent.children.length) {\r\n    return null;\r\n  }\r\n  return getFocusableElements(parent)[0] || null;\r\n};\r\n\r\n/**\r\n * Поиск следующего фокусируемого элемента в переданном родителе\r\n * или на всей странице\r\n * @param {HTMLElement} current - Текущий фокусируемый элемент\r\n * @param {Element|Document|null} [parent=document] - Родительский элемент,\r\n * внутри которого осуществляется поиск.\r\n * @param {boolean} [recursive=true] - Разрешает рекурсивный подъем вверх\r\n * по родителям\r\n * @return {HTMLElement|null} - Найденный элемент или null\r\n *\r\n * В случае поиска по всей странице, можно оставить parent === document,\r\n * тогда результат будет максимально точным, но возможны задержки\r\n * при большом кол-ве фокусируемых элементов на странице.\r\n * Если же передать parent === current.parentElement и recursive === true,\r\n * то поиск осуществится максимально быстро. Но может оказаться не учтенным\r\n * порядок элементов с [tabindex] > 0.\r\n */\r\n\r\nexport const getNextFocusableElement = (\r\n  current: HTMLElement,\r\n  parent: Element | Document | null = document,\r\n  recursive = true,\r\n): HTMLElement | null => {\r\n  if (!parent || !parent.contains(current)) {\r\n    return null;\r\n  }\r\n  if (parent.lastElementChild !== current) {\r\n    const tabbables = getFocusableElements(parent);\r\n    if (tabbables.length > 1) {\r\n      const currentIndex = tabbables.indexOf(current);\r\n      const lastIndex = tabbables.length - 1;\r\n      if (currentIndex === -1) {\r\n        return null;\r\n      }\r\n      if (currentIndex < lastIndex) {\r\n        return tabbables[currentIndex + 1];\r\n      }\r\n    }\r\n  }\r\n  return recursive ? getNextFocusableElement(current, parent.parentElement) : null;\r\n};\r\n\r\n/**\r\n * Поиск ближайшего фокусируемого элемента среди переданного и его родителей\r\n * @param {HTMLElement} current - Текущий элемент\r\n * @return {HTMLElement|null} - Найденный элемент или null\r\n *\r\n */\r\n\r\nexport const getClosestFocusableElement = (current: HTMLElement | null): HTMLElement | null => {\r\n  if (!current) {\r\n    return null;\r\n  }\r\n\r\n  return tabbable.isFocusable(current) ? current : getClosestFocusableElement(current.parentElement);\r\n};\r\n"]}