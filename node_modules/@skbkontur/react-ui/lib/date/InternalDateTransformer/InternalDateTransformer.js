import _extends from "@babel/runtime/helpers/esm/extends";
import { CHAR_PAD, defaultDateComponentsOrder, defaultDateComponentsSeparator, emptyDateComponents, LENGTH_DATE, LENGTH_MONTH, LENGTH_SEPARATOR, LENGTH_YEAR, RE_ORDER_DMY, RE_ORDER_MDY, RE_ORDER_YMD } from "../constants";
import { InternalDateValidator } from "../InternalDateValidator";
import { InternalDateComponentType, InternalDateOrder, InternalDateSeparator } from "../types";
export var InternalDateTransformer =
/*#__PURE__*/
function () {
  function InternalDateTransformer() {}

  InternalDateTransformer.dateToFragments = function dateToFragments(components, settings) {
    if (settings === void 0) {
      settings = {};
    }

    var _settings = settings,
        _settings$order = _settings.order,
        order = _settings$order === void 0 ? defaultDateComponentsOrder : _settings$order,
        _settings$separator = _settings.separator,
        separator = _settings$separator === void 0 ? defaultDateComponentsSeparator : _settings$separator,
        _settings$withSeparat = _settings.withSeparator,
        withSeparator = _settings$withSeparat === void 0 ? false : _settings$withSeparat,
        _settings$withPad = _settings.withPad,
        withPad = _settings$withPad === void 0 ? false : _settings$withPad,
        pad = _settings.pad;
    var year = {
      type: InternalDateComponentType.Year,
      value: components.year,
      length: LENGTH_YEAR
    };
    var month = {
      type: InternalDateComponentType.Month,
      value: components.month,
      length: LENGTH_MONTH
    };
    var date = {
      type: InternalDateComponentType.Date,
      value: components.date,
      length: LENGTH_DATE
    };
    var fragments = [];

    if (order === InternalDateOrder.YMD) {
      fragments.push(year, month, date);
    } else if (order === InternalDateOrder.MDY) {
      fragments.push(month, date, year);
    } else if (order === InternalDateOrder.DMY) {
      fragments.push(date, month, year);
    }

    if (withPad) {
      year.valueWithPad = InternalDateTransformer.padYear(year.value, pad);
      month.valueWithPad = InternalDateTransformer.padMonth(month.value, pad);
      date.valueWithPad = InternalDateTransformer.padDate(date.value, pad);
    }

    year.isValid = InternalDateValidator.testParseToNumber(year.value);
    month.isValid = InternalDateValidator.testParseToNumber(month.value);
    date.isValid = InternalDateValidator.testParseToNumber(date.value);

    if (withSeparator) {
      var separatorFragment = {
        type: InternalDateComponentType.Separator,
        value: separator,
        length: LENGTH_SEPARATOR
      };
      fragments.splice(1, 0, separatorFragment);
      fragments.splice(3, 0, separatorFragment);
    }

    return fragments;
  };

  InternalDateTransformer.parseValueToDate = function parseValueToDate(value, order) {
    if (order === void 0) {
      order = defaultDateComponentsOrder;
    }

    if (!value) {
      return null;
    }

    var re = order === InternalDateOrder.MDY ? RE_ORDER_MDY : order === InternalDateOrder.DMY ? RE_ORDER_DMY : RE_ORDER_YMD;

    if (!re.test(value)) {
      return null;
    }

    var match = re.exec(value);

    var dateComponents = _extends({}, emptyDateComponents);

    if (match) {
      var matchFinished = match.slice(1).map(function (item) {
        return InternalDateValidator.testParseToNumber(item) ? Number(item) : null;
      });

      if (order === InternalDateOrder.YMD) {
        dateComponents.year = matchFinished[0];
        dateComponents.month = matchFinished[1];
        dateComponents.date = matchFinished[2];
      } else if (order === InternalDateOrder.MDY) {
        dateComponents.year = matchFinished[2];
        dateComponents.month = matchFinished[0];
        dateComponents.date = matchFinished[1];
      } else if (order === InternalDateOrder.DMY) {
        dateComponents.year = matchFinished[2];
        dateComponents.month = matchFinished[1];
        dateComponents.date = matchFinished[0];
      }
    }

    return dateComponents;
  };

  InternalDateTransformer.dateComponentsStringToNumber = function dateComponentsStringToNumber(componentsRaw) {
    if (componentsRaw === null) {
      return {
        year: 0,
        month: 0,
        date: 0
      };
    }

    var year = componentsRaw.year,
        month = componentsRaw.month,
        date = componentsRaw.date;
    return {
      year: Number(year),
      month: Number(month),
      date: Number(date)
    };
  };

  InternalDateTransformer.dateToInternalString = function dateToInternalString(components) {
    return InternalDateTransformer.dateToFragments(components, {
      withPad: true,
      withSeparator: false,
      order: InternalDateOrder.DMY
    }).filter(function (_ref) {
      var value = _ref.value;
      return value !== null;
    }).map(function (_ref2) {
      var valueWithPad = _ref2.valueWithPad;
      return valueWithPad;
    }).join(InternalDateSeparator.Dot);
  };

  return InternalDateTransformer;
}();

InternalDateTransformer.padStart = function (value, length, pad) {
  if (pad === void 0) {
    pad = CHAR_PAD;
  }

  return String(value || '').padStart(length, pad);
};

InternalDateTransformer.padYear = function (year, pad) {
  return InternalDateTransformer.padStart(year, LENGTH_YEAR, pad);
};

InternalDateTransformer.padMonth = function (month, pad) {
  return InternalDateTransformer.padStart(month, LENGTH_MONTH, pad);
};

InternalDateTransformer.padDate = function (date, pad) {
  return InternalDateTransformer.padStart(date, LENGTH_DATE, pad);
};

InternalDateTransformer.padDateComponent = function (type, value, pad) {
  if (type === InternalDateComponentType.Year) {
    return InternalDateTransformer.padYear(value, pad);
  } else if (type === InternalDateComponentType.Month) {
    return InternalDateTransformer.padMonth(value, pad);
  } else if (type === InternalDateComponentType.Date) {
    return InternalDateTransformer.padDate(value, pad);
  }

  return '';
};