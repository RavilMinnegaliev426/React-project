import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { ThemeFactory } from "../../../lib/theming/ThemeFactory";
import { FLAT_THEME } from "../../../lib/theming/themes/FlatTheme";
import { DEFAULT_THEME } from "../../../lib/theming/themes/DefaultTheme";
import { SidePage } from "../../../components/SidePage";
import { Gapped } from "../../../components/Gapped";
import { ComboBox } from "../../../components/ComboBox";
import { Link } from "../../../components/Link";
import * as ColorFunctions from "../../../lib/styles/ColorFunctions";
import { ThemeEditor } from "../ThemeEditor";
import { jsStyles } from "../Playground.styles";
import { Playground } from "../Playground";
import { darkTheme } from "../darkTheme";
import { ThemeType } from "../constants";
export var ThemeContextPlayground =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ThemeContextPlayground, _React$Component);

  function ThemeContextPlayground(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.editableThemesItems = [{
      value: ThemeType.Default,
      label: 'Дефолтная'
    }, {
      value: ThemeType.Flat,
      label: 'Плоская'
    }, {
      value: ThemeType.Dark,
      label: 'Темная'
    }];

    _this.renderSidePage = function () {
      var _this$state = _this.state,
          currentTheme = _this$state.currentTheme,
          themesErrors = _this$state.themesErrors,
          editingThemeItem = _this$state.editingThemeItem,
          themes = _this$state.themes;
      var themeErrors = themesErrors[editingThemeItem ? editingThemeItem.value : 'default'];
      return React.createElement(SidePage, {
        disableAnimations: true,
        ignoreBackgroundClick: true,
        blockBackground: true,
        width: 600,
        onClose: _this.handleClose
      }, React.createElement(SidePage.Header, null, React.createElement("div", {
        className: jsStyles.editorHeaderWrapper(currentTheme)
      }, React.createElement(Gapped, {
        wrap: true,
        verticalAlign: "middle"
      }, React.createElement("span", null, "\u0422\u0435\u043C\u0430 \u0434\u043B\u044F \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F:"), React.createElement(ComboBox, {
        getItems: _this.getEditableThemesItems,
        value: editingThemeItem,
        onValueChange: _this.handleEditingThemeSwitch
      }))), React.createElement("div", {
        style: {
          fontSize: 14,
          marginTop: 8
        }
      }, React.createElement(Link, {
        onClick: _this.handelGetTheme
      }, "\u0412\u044B\u0432\u0435\u0441\u0442\u0438 \u0442\u0435\u043C\u0443 \u0432 \u043A\u043E\u043D\u0441\u043E\u043B\u044C"))), React.createElement(SidePage.Body, null, React.createElement("div", {
        className: jsStyles.sidePageBody()
      }, React.createElement(ThemeEditor, {
        editingTheme: themes[editingThemeItem.value],
        currentTheme: currentTheme,
        currentErrors: themeErrors,
        onValueChange: _this.handleThemeVariableChange
      }))));
    };

    _this.handelGetTheme = function () {
      var currentTheme = _this.state.currentTheme;
      var themeObject = {};
      ThemeFactory.getKeys(currentTheme).forEach(function (key) {
        var descriptor = Object.getOwnPropertyDescriptor(currentTheme, key);

        if (descriptor && !descriptor.get && DEFAULT_THEME[key] && currentTheme[key] !== DEFAULT_THEME[key]) {
          themeObject[key] = currentTheme[key];
        }
      });
      console.log(JSON.stringify(themeObject));
    };

    _this.handleOpen = function () {
      _this.setState(function (state) {
        return {
          editorOpened: true,
          editingThemeItem: _this.editableThemesItems.find(function (i) {
            return i.value === state.currentThemeType;
          })
        };
      });
    };

    _this.handleClose = function () {
      _this.setState({
        editorOpened: false
      });
    };

    _this.handleThemeChange = function (value) {
      var themeType = value;

      _this.setState({
        currentThemeType: themeType,
        currentTheme: _this.state.themes[themeType]
      });
    };

    _this.handleThemeVariableChange = function (variable, value) {
      var _this$state2 = _this.state,
          editingThemeItem = _this$state2.editingThemeItem,
          currentTheme = _this$state2.currentTheme,
          themes = _this$state2.themes,
          themesErrors = _this$state2.themesErrors;
      var editingThemeType = editingThemeItem.value;
      var theme = themes[editingThemeType];
      var currentValue = theme[variable];
      var canSetVariable = true;

      if (ColorFunctions.isValid(currentValue)) {
        canSetVariable = ColorFunctions.isValid(value);
        themesErrors[editingThemeType][variable] = !canSetVariable;
      }

      var nextThemeErrors = _extends({}, themesErrors);

      nextThemeErrors[editingThemeType][variable] = !canSetVariable;
      var stateUpdate = {
        themes: themes,
        currentTheme: currentTheme,
        themesErrors: nextThemeErrors
      };

      if (canSetVariable) {
        var result = _this.changeThemeVariable(theme, variable, value);

        stateUpdate.themes[editingThemeType] = result;

        if (_this.state.currentThemeType === editingThemeType) {
          stateUpdate.currentTheme = result;
        }
      }

      _this.setState(stateUpdate);
    };

    _this.getEditableThemesItems = function (query) {
      return Promise.resolve(_this.editableThemesItems.filter(function (i) {
        return i.label.toLowerCase().includes(query.toLowerCase());
      }));
    };

    _this.handleEditingThemeSwitch = function (item) {
      _this.setState({
        editingThemeItem: item
      });
    };

    _this.changeThemeVariable = function (theme, variableName, variableValue) {
      var result = {};
      ThemeFactory.getKeys(theme).forEach(function (key) {
        var descriptor = findPropertyDescriptor(theme, key);
        descriptor.enumerable = true;
        descriptor.configurable = true;

        if (key === variableName) {
          delete descriptor.get;
          delete descriptor.set;
          descriptor.value = variableValue;
        }

        Object.defineProperty(result, key, descriptor);
      });
      return ThemeFactory.create(result);
    };

    _this.state = {
      currentTheme: DEFAULT_THEME,
      currentThemeType: ThemeType.Default,
      editorOpened: false,
      themes: {
        "default": DEFAULT_THEME,
        dark: darkTheme,
        flat: FLAT_THEME
      },
      themesErrors: {
        "default": {},
        dark: {},
        flat: {}
      }
    };
    return _this;
  }

  var _proto = ThemeContextPlayground.prototype;

  _proto.render = function render() {
    var _this$state3 = this.state,
        currentTheme = _this$state3.currentTheme,
        editorOpened = _this$state3.editorOpened,
        currentThemeType = _this$state3.currentThemeType;
    return React.createElement(ThemeContext.Provider, {
      value: currentTheme
    }, editorOpened && this.renderSidePage(), React.createElement(Playground, {
      onThemeChange: this.handleThemeChange,
      currentThemeType: currentThemeType,
      onEditLinkClick: this.handleOpen
    }));
  };

  return ThemeContextPlayground;
}(React.Component);

function findPropertyDescriptor(theme, propName) {
  for (; theme != null; theme = Object.getPrototypeOf(theme)) {
    if (Object.prototype.hasOwnProperty.call(theme, propName)) {
      return Object.getOwnPropertyDescriptor(theme, propName) || {};
    }
  }

  return {};
}