import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import ReactDOM from 'react-dom';
import cn from 'classnames';
import { isKeyArrowDown, isKeyArrowUp, isKeyEnter } from "../../../lib/events/keyboard/identifiers";
import { ScrollContainer } from "../../../components/ScrollContainer";
import { isMenuItem } from "../../../components/MenuItem";
import { isMenuHeader } from "../../../components/MenuHeader";
import { createPropsGetter } from "../../../lib/createPropsGetter";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { jsStyles } from "../InternalMenu.styles";
import { isActiveElement } from "../isActiveElement";
export var InternalMenu =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(InternalMenu, _React$Component);

  function InternalMenu() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      highlightedIndex: -1,
      maxHeight: _this.props.maxHeight || 'none',
      scrollState: 'top'
    };
    _this.theme = void 0;
    _this.scrollContainer = void 0;
    _this.highlighted = void 0;
    _this.rootElement = void 0;
    _this.header = void 0;
    _this.footer = void 0;
    _this.getProps = createPropsGetter(InternalMenu.defaultProps);

    _this.renderHeader = function () {
      var _cn;

      return React.createElement("div", {
        ref: function ref(el) {
          return _this.header = el;
        },
        className: cn((_cn = {}, _cn[jsStyles.header()] = true, _cn[jsStyles.fixedHeader()] = _this.state.scrollState !== 'top', _cn))
      }, _this.props.header);
    };

    _this.renderFooter = function () {
      var _cn2;

      return React.createElement("div", {
        ref: function ref(el) {
          return _this.footer = el;
        },
        className: cn((_cn2 = {}, _cn2[jsStyles.footer()] = true, _cn2[jsStyles.fixedFooter()] = _this.state.scrollState !== 'bottom', _cn2))
      }, _this.props.footer);
    };

    _this.focusOnRootElement = function () {
      if (_this.rootElement) {
        _this.rootElement.focus();
      }
    };

    _this.shouldRecalculateMaxHeight = function (prevProps) {
      var _this$props = _this.props,
          maxHeight = _this$props.maxHeight,
          header = _this$props.header,
          footer = _this$props.footer,
          children = _this$props.children;
      var prevMaxHeight = prevProps.maxHeight;
      var prevHeader = prevProps.header;
      var prevFooter = prevProps.footer;
      var prevChildrenCount = React.Children.count(prevProps.children);
      return maxHeight !== prevMaxHeight || footer !== prevFooter || header !== prevHeader || React.Children.count(children) !== prevChildrenCount;
    };

    _this.calculateMaxHeight = function () {
      var maxHeight = _this.props.maxHeight;
      var parsedMaxHeight = maxHeight;

      if (typeof maxHeight === 'string' && typeof window !== 'undefined' && _this.rootElement) {
        var rootElementMaxHeight = window.getComputedStyle(_this.rootElement).maxHeight;

        if (rootElementMaxHeight) {
          parsedMaxHeight = parseFloat(rootElementMaxHeight);
        }
      }

      var calculatedMaxHeight = typeof parsedMaxHeight === 'number' ? parsedMaxHeight + (_this.header && _this.header.getBoundingClientRect().height || 0) + (_this.footer && _this.footer.getBoundingClientRect().height || 0) : maxHeight;

      _this.setState({
        maxHeight: calculatedMaxHeight || 'none'
      });
    };

    _this.setInitialSelection = function () {
      for (var i = _this.getProps().initialSelectedItemIndex; i > -1; i--) {
        _this.moveDown();
      }
    };

    _this.refScrollContainer = function (scrollContainer) {
      _this.scrollContainer = scrollContainer;
    };

    _this.scrollToSelected = function () {
      if (_this.scrollContainer && _this.highlighted) {
        _this.scrollContainer.scrollTo(ReactDOM.findDOMNode(_this.highlighted));
      }
    };

    _this.highlightItem = function (index) {
      _this.setState({
        highlightedIndex: index
      });

      if (_this.rootElement) {
        _this.rootElement.focus();
      }
    };

    _this.unhighlight = function () {
      _this.setState({
        highlightedIndex: -1
      });
    };

    _this.moveUp = function () {
      _this.move(-1);
    };

    _this.moveDown = function () {
      _this.move(1);
    };

    _this.handleKeyDown = function (e) {
      if (typeof _this.props.onKeyDown === 'function') {
        _this.props.onKeyDown(e);
      }

      if (e.defaultPrevented) {
        return;
      }

      if (isKeyArrowUp(e)) {
        e.preventDefault();

        _this.moveUp();
      } else if (isKeyArrowDown(e)) {
        e.preventDefault();

        _this.moveDown();
      } else if (isKeyEnter(e)) {
        if (_this.highlighted && _this.highlighted.props.onClick) {
          _this.highlighted.props.onClick(e);
        }
      }
    };

    _this.handleScrollStateChange = function (scrollState) {
      if (_this.state.scrollState !== scrollState) {
        _this.setState({
          scrollState: scrollState
        });
      }
    };

    return _this;
  }

  var _proto = InternalMenu.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.setInitialSelection();
    this.calculateMaxHeight();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (this.shouldRecalculateMaxHeight(prevProps)) {
      this.calculateMaxHeight();
    }
  };

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.maxHeight !== this.props.maxHeight) {
      this.setState({
        maxHeight: nextProps.maxHeight || 'none'
      });
    }
  };

  _proto.focus = function focus() {
    this.focusOnRootElement();
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  };

  _proto.renderMain = function renderMain() {
    var _cn3,
        _this3 = this;

    var enableIconPadding = React.Children.toArray(this.props.children).some(function (x) {
      return React.isValidElement(x) && x.props.icon;
    });

    if (this.isEmpty()) {
      return null;
    }

    return React.createElement("div", {
      className: cn((_cn3 = {}, _cn3[jsStyles.root(this.theme)] = true, _cn3[jsStyles.shadow()] = this.props.hasShadow, _cn3)),
      style: {
        width: this.props.width,
        maxHeight: this.state.maxHeight
      },
      onKeyDown: this.handleKeyDown,
      ref: function ref(element) {
        _this3.rootElement = element;
      },
      tabIndex: 0
    }, this.props.header ? this.renderHeader() : null, React.createElement(ScrollContainer, {
      ref: this.refScrollContainer,
      maxHeight: this.props.maxHeight,
      preventWindowScroll: this.props.preventWindowScroll,
      onScrollStateChange: this.handleScrollStateChange
    }, React.Children.map(this.props.children, function (child, index) {
      if (typeof child === 'string' || typeof child === 'number' || child == null) {
        return child;
      }

      if (React.isValidElement(child) && typeof child.type === 'string') {
        return child;
      }

      if (enableIconPadding && (isMenuItem(child) || isMenuHeader(child))) {
        child = React.cloneElement(child, {
          _enableIconPadding: true
        });
      }

      if (isActiveElement(child)) {
        var highlight = _this3.state.highlightedIndex === index;
        var ref = child.ref;
        var originalRef = ref;

        if (highlight) {
          ref = function ref(menuItem) {
            return _this3.refHighlighted(originalRef, menuItem);
          };
        }

        return React.cloneElement(child, {
          ref: ref,
          state: highlight ? 'hover' : child.props.state,
          onClick: _this3.select.bind(_this3, index, false),
          onMouseEnter: function onMouseEnter(event) {
            _this3.highlightItem(index);

            if (isMenuItem(child) && child.props.onMouseEnter) {
              child.props.onMouseEnter(event);
            }
          },
          onMouseLeave: function onMouseLeave(event) {
            _this3.unhighlight();

            if (isMenuItem(child) && child.props.onMouseLeave) {
              child.props.onMouseLeave(event);
            }
          }
        });
      }

      return child;
    })), this.props.footer ? this.renderFooter() : null);
  };

  _proto.refHighlighted = function refHighlighted(originalRef, menuItem) {
    this.highlighted = menuItem;

    if (!originalRef || typeof originalRef === 'string') {
      return;
    }

    if (typeof originalRef === 'function') {
      originalRef(menuItem);
    } else if (typeof originalRef === 'object') {
      // @ts-ignore see issue https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065
      originalRef.current = menuItem;
    }
  };

  _proto.select = function select(index, shouldHandleHref, event) {
    var item = childrenToArray(this.props.children)[index];

    if (isActiveElement(item)) {
      if (shouldHandleHref && item.props.href) {
        if (item.props.target) {
          window.open(item.props.href, item.props.target);
        } else {
          location.href = item.props.href;
        }
      }

      if (item.props.onClick) {
        item.props.onClick(event);
      }

      if (this.props.onItemClick) {
        this.props.onItemClick(event);
      }

      return true;
    }

    return false;
  };

  _proto.move = function move(step) {
    this.setState(function (state, props) {
      var children = childrenToArray(props.children);

      if (!children.some(isActiveElement)) {
        return null;
      }

      var index = state.highlightedIndex;

      do {
        index += step;

        if (!props.cyclicSelection && (index < 0 || index > children.length)) {
          return null;
        }

        if (index < 0) {
          index = children.length - 1;
        } else if (index > children.length) {
          index = 0;
        }

        var child = children[index];

        if (isActiveElement(child)) {
          return {
            highlightedIndex: index
          };
        }
      } while (index !== state.highlightedIndex);

      return null;
    }, this.scrollToSelected);
  };

  _proto.isEmpty = function isEmpty() {
    var children = this.props.children;
    return !children || !childrenToArray(children).filter(isExist).length;
  };

  return InternalMenu;
}(React.Component);
InternalMenu.__KONTUR_REACT_UI__ = 'InternalMenu';
InternalMenu.defaultProps = {
  width: 'auto',
  maxHeight: 300,
  hasShadow: true,
  preventWindowScroll: true,
  cyclicSelection: true,
  initialSelectedItemIndex: -1
};

function isExist(value) {
  return value !== null && value !== undefined;
}

function childrenToArray(children) {
  var ret = []; // Use forEach instead of map to avoid cloning for key unifying.

  React.Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}