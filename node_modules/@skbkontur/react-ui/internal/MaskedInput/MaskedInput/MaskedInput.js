import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import ReactInputMask from 'react-input-mask';
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { jsStyles } from "../MaskedInput.styles";
export var MaskedInput =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(MaskedInput, _React$Component);

  function MaskedInput(_props) {
    var _this;

    _this = _React$Component.call(this, _props) || this;
    _this.input = null;
    _this.theme = void 0;
    _this.reactInputMask = null;

    _this.getValue = function (props) {
      var value = props.value,
          defaultValue = props.defaultValue;
      return value !== undefined ? value.toString() : defaultValue !== undefined ? defaultValue.toString() : '';
    };

    _this.refInput = function (input) {
      _this.input = input;
    };

    _this.refMaskedInput = function (reactInputMask) {
      _this.reactInputMask = reactInputMask;
    };

    _this.handleChange = function (event) {
      if (event.target.value === _this.state.value) {
        _this.handleUnexpectedInput();
      } else {
        _this.setState({
          value: event.target.value
        });

        if (_this.props.onValueChange) {
          _this.props.onValueChange(event.target.value);
        }

        if (_this.props.onChange) {
          _this.props.onChange(event);
        }
      }
    };

    _this.handleFocus = function (event) {
      _this.setState({
        focused: true
      });

      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };

    _this.handleBlur = function (event) {
      _this.setState({
        focused: false
      });

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    };

    _this.preprocess = function (newState, oldState, userInput, options) {
      var visibleMaskChars = new Array(options.mask.length).fill(_this.props.maskChar);

      if (newState.value !== oldState.value && userInput === null) {
        _this.setState({
          value: newState.value
        });
      }

      options.mask.split('').forEach(function (_char, index) {
        if (options.permanents.includes(index)) {
          visibleMaskChars[index] = _char;
        }

        if (newState.value[index]) {
          visibleMaskChars[index] = newState.value[index];
        }
      });
      var emptyValue = visibleMaskChars.join('');

      if (_this.state.emptyValue !== emptyValue) {
        _this.setState({
          emptyValue: emptyValue
        });
      }

      return newState;
    };

    _this.isMaskVisible = function () {
      return _this.props.alwaysShowMask || _this.state.focused;
    };

    _this.handleUnexpectedInput = function () {
      if (_this.props.onUnexpectedInput) {
        _this.props.onUnexpectedInput(_this.state.value);
      }
    };

    _this.state = {
      value: _this.getValue(_props),
      emptyValue: '',
      focused: false
    };
    return _this;
  }

  var _proto = MaskedInput.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.reactInputMask) {
      // FIXME: принудительно вызываем beforeMaskedValueChange, чтобы получить emptyValue
      this.reactInputMask.forceUpdate();
    }
  };

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.value !== nextProps.value) {
      this.setState({
        value: nextProps.value ? nextProps.value.toString() : ''
      });
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  };

  _proto.renderMain = function renderMain() {
    var _this$props = this.props,
        maskChar = _this$props.maskChar,
        alwaysShowMask = _this$props.alwaysShowMask,
        hasLeftIcon = _this$props.hasLeftIcon,
        hasRightIcon = _this$props.hasRightIcon,
        maxLength = _this$props.maxLength,
        onValueChange = _this$props.onValueChange,
        onUnexpectedInput = _this$props.onUnexpectedInput,
        defaultValue = _this$props.defaultValue,
        inputProps = _objectWithoutPropertiesLoose(_this$props, ["maskChar", "alwaysShowMask", "hasLeftIcon", "hasRightIcon", "maxLength", "onValueChange", "onUnexpectedInput", "defaultValue"]);

    return React.createElement("span", {
      className: jsStyles.container(),
      "x-ms-format-detection": "none"
    }, React.createElement(ReactInputMask, _extends({}, inputProps, {
      maskChar: null,
      beforeMaskedValueChange: this.preprocess,
      alwaysShowMask: false,
      onChange: this.handleChange,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      value: this.state.value,
      inputRef: this.refInput,
      ref: this.refMaskedInput
    })), this.isMaskVisible() && React.createElement("span", {
      className: jsStyles.inputMask(this.theme)
    }, React.createElement("span", {
      style: {
        color: 'transparent'
      }
    }, this.state.emptyValue.slice(0, this.state.value.length)), this.state.emptyValue.slice(this.state.value.length)));
  };

  return MaskedInput;
}(React.Component);
MaskedInput.__KONTUR_REACT_UI__ = 'MaskedInput';