import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import normalizeWheel from 'normalize-wheel';
import { MAX_DATE, MAX_MONTH, MAX_YEAR, MIN_DATE, MIN_MONTH, MIN_YEAR } from "../../../lib/date/constants";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { Animation } from "../../../lib/animation";
import { config } from "../config";
import * as CalendarUtils from "../CalendarUtils";
import { MonthViewModel } from "../MonthViewModel";
import * as CalendarScrollEvents from "../CalendarScrollEvents";
import { Month } from "../Month";
import { jsStyles } from "../Calendar.styles";
import { create, isGreater, isLess } from "../CalendarDateShape";

var getTodayDate = function getTodayDate() {
  var date = new Date();
  return {
    date: date.getDate(),
    month: date.getMonth(),
    year: date.getFullYear()
  };
};

var wrapperStyle = {
  height: config.WRAPPER_HEIGHT
};
export var Calendar =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Calendar, _React$Component);

  function Calendar(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.theme = void 0;
    _this.wheelEndTimeout = void 0;
    _this.root = void 0;
    _this.animation = Animation();

    _this.scrollToMonth =
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(month, year) {
        var _this$props, minDate, maxDate, currentMonth, diffInMonths, maxMonthsToAdd, onEnd, isYearChanges, monthsToPrependCount, monthsToPrepend, monthsToAppendCount, monthsToAppend;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!_this.animation.inProgress()) {
                  _context.next = 4;
                  break;
                }

                _this.animation.finish(); // FIXME: Dirty hack to await batched updates


                _context.next = 4;
                return new Promise(function (r) {
                  return setTimeout(r);
                });

              case 4:
                _this$props = _this.props, minDate = _this$props.minDate, maxDate = _this$props.maxDate;

                if (!(minDate && isGreater(minDate, create(32, month, year)))) {
                  _context.next = 8;
                  break;
                }

                _this.scrollToMonth(minDate.month, minDate.year);

                return _context.abrupt("return");

              case 8:
                if (!(maxDate && isLess(maxDate, create(0, month, year)))) {
                  _context.next = 11;
                  break;
                }

                _this.scrollToMonth(maxDate.month, maxDate.year);

                return _context.abrupt("return");

              case 11:
                currentMonth = _this.state.months[1];
                diffInMonths = currentMonth.month + currentMonth.year * 12 - month - year * 12;

                if (!(diffInMonths === 0)) {
                  _context.next = 16;
                  break;
                }

                _this.scrollTo(0);

                return _context.abrupt("return");

              case 16:
                maxMonthsToAdd = config.MAX_MONTHS_TO_APPEND_ON_SCROLL;

                onEnd = function onEnd() {
                  return _this.setState({
                    months: CalendarUtils.getMonths(month, year),
                    scrollPosition: 0
                  });
                };

                isYearChanges = function isYearChanges(state) {
                  return state.months[1].year !== year && // if diff in months is 2 or less,
                  // either year is not changing either months already
                  // have right isFirstInYear/isLastInYear flags
                  Math.abs(diffInMonths) > 2;
                }; // If scrolling upwards, prepend maximum maxMonthsToAdd months
                // and scroll to the first month


                if (diffInMonths > 0) {
                  monthsToPrependCount = Math.min(Math.abs(diffInMonths) - 1, maxMonthsToAdd);
                  monthsToPrepend = Array.from({
                    length: monthsToPrependCount
                  }, function (_, index) {
                    return MonthViewModel.create(month + index, year);
                  });

                  _this.setState(function (state) {
                    var yearChanges = isYearChanges(state);

                    if (yearChanges) {
                      // Mutating here can lead to some unexpected bugs
                      // but we couldn't find any yet
                      state.months[0].isFirstInYear = true;

                      if (monthsToPrepend.length) {
                        // Mutating item here is safe as it was just created
                        monthsToPrepend[monthsToPrepend.length - 1].isLastInYear = true;
                      }
                    }

                    return {
                      months: monthsToPrepend.concat(state.months),
                      scrollPosition: -CalendarUtils.getMonthsHeight(monthsToPrepend)
                    };
                  }, function () {
                    var targetPosition = _this.state.months[0].height;

                    _this.scrollTo(targetPosition, onEnd);
                  });
                } // If scrolling downwards, append maximum maxMonthsToAdd months
                // and scroll to the last but one month


                if (diffInMonths < 0) {
                  monthsToAppendCount = Math.min(Math.abs(diffInMonths), maxMonthsToAdd);
                  monthsToAppend = Array.from({
                    length: monthsToAppendCount
                  }, function (_, index) {
                    return MonthViewModel.create(month + index - monthsToAppendCount + 2, year);
                  });

                  _this.setState(function (state) {
                    if (isYearChanges(state)) {
                      // Mutating here can lead to some unexpected bugs
                      // but we couldn't find any yet
                      state.months[state.months.length - 1].isLastInYear = true; // Mutating item here is safe as it was just created

                      if (monthsToAppend[0]) {
                        monthsToAppend[0].isFirstInYear = true;
                      }
                    }

                    return {
                      months: state.months.concat(monthsToAppend)
                    };
                  }, function () {
                    var targetPosition = -1 * CalendarUtils.getMonthsHeight(_this.state.months.slice(1, -2));

                    _this.scrollTo(targetPosition, onEnd);
                  });
                }

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();

    _this.renderMain = function () {
      var positions = _this.getMonthPositions();

      return React.createElement("div", {
        ref: _this.refRoot,
        className: jsStyles.root(_this.theme)
      }, React.createElement("div", {
        style: wrapperStyle,
        className: jsStyles.wrapper()
      }, _this.state.months.map(function (x, i) {
        return [positions[i], x];
      }).filter(function (_ref2) {
        var top = _ref2[0],
            month = _ref2[1];
        return CalendarUtils.isMonthVisible(top, month);
      }).map(_this.renderMonth, _assertThisInitialized(_this))));
    };

    _this.refRoot = function (element) {
      if (!_this.root && element) {
        element.addEventListener('wheel', _this.handleWheel, {
          passive: false
        });
      }

      if (_this.root && !element) {
        _this.root.removeEventListener('wheel', _this.handleWheel);
      }

      _this.root = element;
    };

    _this.handleMonthYearChange = function (month, year) {
      _this.scrollToMonth(month, year);
    };

    _this.handleWheel = function (event) {
      if (!(event instanceof WheelEvent)) {
        return;
      }

      event.preventDefault();

      var _normalizeWheel = normalizeWheel(event),
          pixelY = _normalizeWheel.pixelY;

      _this.setState(function (_ref3) {
        var months = _ref3.months,
            scrollPosition = _ref3.scrollPosition,
            scrollTarget = _ref3.scrollTarget;
        var targetPosition = CalendarUtils.calculateScrollPosition(months, scrollPosition, pixelY).scrollPosition;
        return {
          scrollTarget: targetPosition
        };
      }, _this.handleWheelEnd);

      _this.animation.animate(pixelY, function (deltaY) {
        return (// FIXME: Typescript not resolving setState cb type
          _this.setState(CalendarUtils.applyDelta(deltaY))
        );
      });

      CalendarScrollEvents.emit();
    };

    _this.handleWheelEnd = function () {
      if (_this.wheelEndTimeout) {
        clearTimeout(_this.wheelEndTimeout);
      }

      _this.wheelEndTimeout = window.setTimeout(_this.scrollToNearestWeek, 300);
    };

    _this.scrollToNearestWeek = function () {
      var _this$state = _this.state,
          scrollTarget = _this$state.scrollTarget,
          scrollDirection = _this$state.scrollDirection;
      var trasholdHeight = config.MONTH_TITLE_OFFSET_HEIGHT + config.DAY_HEIGHT;

      if (scrollTarget < trasholdHeight) {
        var targetPosition = 0;

        if (scrollDirection < 0) {
          targetPosition = trasholdHeight;
        }

        _this.setState({
          scrollTarget: targetPosition
        }, function () {
          var amount = scrollTarget - targetPosition;

          _this.animation.animate(amount, function (deltaY) {
            return (// FIXME: Typescript not resolving setState cb type
              _this.setState(CalendarUtils.applyDelta(deltaY))
            );
          });
        });
      }
    };

    _this.scrollTo = function (pos, onEnd) {
      var scrollAmmount = pos - _this.state.scrollPosition;
      return _this.scrollAmount(scrollAmmount, onEnd);
    };

    _this.scrollAmount = function (scrollAmmount, onEnd) {
      return _this.animation.animate(scrollAmmount, function (deltaY) {
        return _this.setState(function (_ref4) {
          var scrollPosition = _ref4.scrollPosition;
          return {
            scrollPosition: scrollPosition + deltaY
          };
        });
      }, onEnd);
    };

    var today = getTodayDate();
    var initialMonth = props.initialMonth == null ? today.month : props.initialMonth;
    var initialYear = props.initialYear == null ? today.year : props.initialYear;
    _this.state = {
      scrollPosition: 0,
      months: CalendarUtils.getMonths(initialMonth, initialYear),
      today: today,
      scrollDirection: 1,
      scrollTarget: 0
    };
    return _this;
  }

  var _proto = Calendar.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.animation.inProgress()) {
      this.animation.cancel();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  }
  /**
   * Scrolls calendar to given date
   * @public
   */
  ;

  _proto.renderMonth = function renderMonth(_ref5) {
    var top = _ref5[0],
        month = _ref5[1];
    return React.createElement(Month, {
      key: month.month + '-' + month.year,
      top: top,
      month: month,
      maxDate: this.props.maxDate,
      minDate: this.props.minDate,
      today: this.state.today,
      value: this.props.value,
      onDateClick: this.props.onSelect,
      onMonthYearChange: this.handleMonthYearChange,
      isHoliday: this.props.isHoliday
    });
  };

  _proto.getMonthPositions = function getMonthPositions() {
    var _this$state2 = this.state,
        scrollPosition = _this$state2.scrollPosition,
        months = _this$state2.months;
    var positions = [scrollPosition - months[0].height];

    for (var i = 1; i < months.length; i++) {
      var position = positions[i - 1] + months[i - 1].height;
      positions.push(position);
    }

    return positions;
  };

  return Calendar;
}(React.Component);
Calendar.__KONTUR_REACT_UI__ = 'Calendar';
Calendar.defaultProps = {
  holidays: [],
  minDate: {
    year: MIN_YEAR,
    month: MIN_MONTH,
    date: MIN_DATE
  },
  maxDate: {
    year: MAX_YEAR,
    month: MAX_MONTH,
    date: MAX_DATE
  }
};