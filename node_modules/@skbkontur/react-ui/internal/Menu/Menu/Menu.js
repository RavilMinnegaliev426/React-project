import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import ReactDOM from 'react-dom';
import cn from 'classnames';
import { ScrollContainer } from "../../../components/ScrollContainer";
import { isMenuItem } from "../../../components/MenuItem";
import { isMenuHeader } from "../../../components/MenuHeader";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { jsStyles } from "../Menu.styles";
import { isActiveElement } from "../isActiveElement";
export var Menu =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Menu, _React$Component);

  function Menu() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      highlightedIndex: -1
    };
    _this.theme = void 0;
    _this.scrollContainer = void 0;
    _this.highlighted = void 0;
    _this.unmounted = false;

    _this.refScrollContainer = function (scrollContainer) {
      _this.scrollContainer = scrollContainer;
    };

    _this.scrollToSelected = function () {
      if (_this.scrollContainer && _this.highlighted) {
        _this.scrollContainer.scrollTo(ReactDOM.findDOMNode(_this.highlighted));
      }
    };

    _this.scrollToTop = function () {
      if (_this.scrollContainer) {
        _this.scrollContainer.scrollToTop();
      }
    };

    _this.scrollToBottom = function () {
      if (_this.scrollContainer) {
        _this.scrollContainer.scrollToBottom();
      }
    };

    _this.highlight = function (index) {
      _this.setState({
        highlightedIndex: index
      });
    };

    _this.unhighlight = function () {
      _this.setState({
        highlightedIndex: -1
      });
    };

    return _this;
  }

  var _proto = Menu.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unmounted = true;
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  }
  /**
   * @public
   */
  ;

  _proto.up = function up() {
    this.move(-1);
  }
  /**
   * @public
   */
  ;

  _proto.down = function down() {
    this.move(1);
  }
  /**
   * @public
   */
  ;

  _proto.enter = function enter(event) {
    return this.select(this.state.highlightedIndex, true, event);
  }
  /**
   * @public
   */
  ;

  _proto.reset = function reset() {
    this.setState({
      highlightedIndex: -1
    });
  }
  /**
   * @public
   */
  ;

  _proto.hasHighlightedItem = function hasHighlightedItem() {
    return this.state.highlightedIndex !== -1;
  };

  _proto.highlightItem = function highlightItem(index) {
    this.highlight(index);
  };

  _proto.renderMain = function renderMain() {
    var _cn,
        _this3 = this;

    var enableIconPadding = React.Children.toArray(this.props.children).some(function (x) {
      return React.isValidElement(x) && x.props.icon;
    });

    if (this.isEmpty()) {
      return null;
    }

    return React.createElement("div", {
      className: cn((_cn = {}, _cn[jsStyles.root(this.theme)] = true, _cn[jsStyles.shadow(this.theme)] = this.props.hasShadow, _cn)),
      style: {
        width: this.props.width,
        maxHeight: this.props.maxHeight
      }
    }, React.createElement(ScrollContainer, {
      ref: this.refScrollContainer,
      maxHeight: this.props.maxHeight,
      preventWindowScroll: this.props.preventWindowScroll
    }, React.Children.map(this.props.children, function (child, index) {
      if (!child) {
        return child;
      }

      if (typeof child === 'string' || typeof child === 'number') {
        return child;
      }

      if (enableIconPadding && (isMenuItem(child) || isMenuHeader(child))) {
        child = React.cloneElement(child, {
          _enableIconPadding: true
        });
      }

      if (isActiveElement(child)) {
        var highlight = _this3.state.highlightedIndex === index;
        var ref = child.ref;

        if (highlight && typeof child.ref !== 'string') {
          ref = _this3.refHighlighted.bind(_this3, child.ref);
        }

        return React.cloneElement(child, {
          ref: ref,
          state: highlight ? 'hover' : child.props.state,
          onClick: _this3.select.bind(_this3, index, false),
          onMouseEnter: _this3.highlight.bind(_this3, index),
          onMouseLeave: _this3.unhighlight
        });
      }

      return child;
    })));
  };

  _proto.refHighlighted = function refHighlighted(originalRef, menuItem) {
    this.highlighted = menuItem;

    if (typeof originalRef === 'function') {
      originalRef(menuItem);
    }
  };

  _proto.select = function select(index, shouldHandleHref, event) {
    var item = childrenToArray(this.props.children)[index];

    if (isActiveElement(item)) {
      if (shouldHandleHref && item.props.href) {
        if (item.props.target) {
          window.open(item.props.href, item.props.target);
        } else {
          location.href = item.props.href;
        }
      }

      if (item.props.onClick) {
        item.props.onClick(event);
      }

      if (this.props.onItemClick) {
        this.props.onItemClick();
      }

      return true;
    }

    return false;
  };

  _proto.move = function move(step) {
    var _this4 = this;

    if (this.unmounted) {
      // NOTE workaround, because `ComboBox` call `process.nextTick` in reducer
      return;
    }

    var children = childrenToArray(this.props.children);
    var activeElements = children.filter(isActiveElement);

    if (!activeElements.length) {
      return;
    }

    var index = this.state.highlightedIndex;

    var _loop = function _loop() {
      index += step;

      if (index < 0) {
        index = children.length - 1;
      } else if (index > children.length) {
        index = 0;
      }

      var child = children[index];

      if (isActiveElement(child)) {
        _this4.setState({
          highlightedIndex: index
        }, function () {
          switch (activeElements.indexOf(child)) {
            case 0:
              _this4.scrollToTop();

              break;

            case activeElements.length - 1:
              _this4.scrollToBottom();

              break;

            default:
              _this4.scrollToSelected();

          }
        });

        return {
          v: void 0
        };
      }
    };

    do {
      var _ret = _loop();

      if (typeof _ret === "object") return _ret.v;
    } while (index !== this.state.highlightedIndex);
  };

  _proto.isEmpty = function isEmpty() {
    var children = this.props.children;
    return !children || !childrenToArray(children).filter(isExist).length;
  };

  return Menu;
}(React.Component);
Menu.__KONTUR_REACT_UI__ = 'Menu';
Menu.defaultProps = {
  width: 'auto',
  maxHeight: 300,
  hasShadow: true,
  preventWindowScroll: true
};

function isExist(value) {
  return value !== null && value !== undefined;
}

function childrenToArray(children) {
  var ret = []; // Use forEach instead of map to avoid cloning for key unifying.

  React.Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}