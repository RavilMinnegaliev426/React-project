import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import { PopupHelper } from "../PopupHelper";
import { jsStyles } from "../PopupPin.styles";
var borderStyles = {
  position: 'absolute',
  borderStyle: 'solid',
  borderTopColor: 'transparent',
  borderBottomColor: 'transparent',
  borderLeftColor: 'transparent',
  borderRightColor: 'transparent'
};
export var PopupPin =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(PopupPin, _React$Component);

  function PopupPin() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = PopupPin.prototype;

  _proto.render = function render() {
    if (!this.props.popupElement) {
      return null;
    }

    var options = this.getPinOptions(PopupHelper.getElementAbsoluteRect(this.props.popupElement), PopupHelper.getPositionObject(this.props.popupPosition), this.props.size, this.props.offset, this.props.borderWidth);
    var styleOuter = this.getOuterStyle(options.activeBorder, options.outerSize, this.props.borderColor);
    var styleInner = this.getInnerStyle(options.activeBorder, this.props.size, this.props.backgroundColor);
    var styleWrapper = this.getWrapperStyle(options.outerLeft, options.outerTop, options.outerSize);
    return React.createElement("div", {
      className: jsStyles.wrapper(),
      style: styleWrapper
    }, React.createElement("div", {
      style: styleOuter
    }, React.createElement("div", {
      style: styleInner
    })));
  };

  _proto.getPopupOppositeDirection = function getPopupOppositeDirection() {
    var popupDirection = PopupHelper.getPositionObject(this.props.popupPosition).direction;

    switch (popupDirection) {
      case 'top':
        return 'bottom';

      case 'bottom':
        return 'top';

      case 'left':
        return 'right';

      case 'right':
        return 'left';

      default:
        throw new TypeError('Unknown direction ' + popupDirection);
    }
  };

  _proto.getWrapperStyle = function getWrapperStyle(left, top, borderWidth) {
    var _ref, _ref2;

    var direction = this.getPopupOppositeDirection();

    switch (direction) {
      case 'top':
      case 'bottom':
        return _ref = {}, _ref[direction] = -borderWidth + 'px', _ref.left = left + 'px', _ref.width = borderWidth * 2 + 'px', _ref.height = borderWidth + 'px', _ref;

      case 'left':
      case 'right':
        return _ref2 = {}, _ref2[direction] = -borderWidth + 'px', _ref2.top = top + 'px', _ref2.height = borderWidth * 2 + 'px', _ref2.width = borderWidth + 'px', _ref2;

      default:
        throw new TypeError('Unknown direction ' + direction);
    }
  };

  _proto.getOuterStyle = function getOuterStyle(activeBorder, borderWitdth, borderColor) {
    var _extends2, _extends3;

    var direction = this.getPopupOppositeDirection();

    switch (direction) {
      case 'top':
      case 'bottom':
        return _extends({}, borderStyles, (_extends2 = {}, _extends2[direction] = -borderWitdth + 'px', _extends2.left = '0px', _extends2.borderWidth = borderWitdth + 'px', _extends2['border' + activeBorder + 'Color'] = borderColor, _extends2));

      case 'left':
      case 'right':
        return _extends({}, borderStyles, (_extends3 = {}, _extends3[direction] = -borderWitdth + 'px', _extends3.top = '0px', _extends3.borderWidth = borderWitdth + 'px', _extends3['border' + activeBorder + 'Color'] = borderColor, _extends3));

      default:
        throw new TypeError('Unknown direction ' + direction);
    }
  };

  _proto.getInnerStyle = function getInnerStyle(activeBorder, borderWitdth, borderColor) {
    var _extends4, _extends5;

    var direction = this.getPopupOppositeDirection();

    switch (direction) {
      case 'top':
      case 'bottom':
        return _extends({}, borderStyles, (_extends4 = {}, _extends4[direction] = -borderWitdth + 2 + 'px', _extends4.left = -borderWitdth + 'px', _extends4.borderWidth = borderWitdth + 'px', _extends4['border' + activeBorder + 'Color'] = borderColor, _extends4));

      case 'left':
      case 'right':
        return _extends({}, borderStyles, (_extends5 = {}, _extends5[direction] = -borderWitdth + 2 + 'px', _extends5.top = -borderWitdth + 'px', _extends5.borderWidth = borderWitdth + 'px', _extends5['border' + activeBorder + 'Color'] = borderColor, _extends5));

      default:
        throw new TypeError('Unknown direction ' + direction);
    }
  };

  _proto.getPinOptions = function getPinOptions(popupRect, popupPosition, pinSize, pinOffset, borderWidth) {
    var bordersDelta = 2 * borderWidth;
    var outerSize = pinSize + bordersDelta;

    switch (popupPosition.direction) {
      case 'top':
        return {
          outerTop: popupRect.height,
          outerLeft: this.getPinLeftCoordinate(popupRect, popupPosition.align, pinSize, pinOffset) - bordersDelta,
          innerTop: -outerSize,
          innerLeft: -outerSize + bordersDelta,
          activeBorder: 'Top',
          outerSize: outerSize
        };

      case 'bottom':
        return {
          outerTop: -2 * outerSize,
          outerLeft: this.getPinLeftCoordinate(popupRect, popupPosition.align, pinSize, pinOffset) - bordersDelta,
          innerTop: -outerSize + 2 * bordersDelta,
          innerLeft: -outerSize + bordersDelta,
          activeBorder: 'Bottom',
          outerSize: outerSize
        };

      case 'left':
        return {
          outerTop: this.getPinTopCoordinate(popupRect, popupPosition.align, pinSize, pinOffset) - bordersDelta,
          outerLeft: popupRect.width,
          innerTop: -outerSize + bordersDelta,
          innerLeft: -outerSize,
          activeBorder: 'Left',
          outerSize: outerSize
        };

      case 'right':
        return {
          outerTop: this.getPinTopCoordinate(popupRect, popupPosition.align, pinSize, pinOffset) - bordersDelta,
          outerLeft: -2 * outerSize,
          innerTop: -outerSize + bordersDelta,
          innerLeft: -outerSize + 2 * bordersDelta,
          activeBorder: 'Right',
          outerSize: outerSize
        };

      default:
        throw new Error('Direction must be one of top, right, bottom, left');
    }
  };

  _proto.getPinTopCoordinate = function getPinTopCoordinate(popupRect, align, pinHeight, pinOffset) {
    switch (align) {
      case 'top':
        return pinOffset;

      case 'middle':
        return popupRect.height / 2 - pinHeight;

      case 'bottom':
        return popupRect.height - pinOffset - 2 * pinHeight;

      default:
        throw new Error("Unexpected align '" + align + "'");
    }
  };

  _proto.getPinLeftCoordinate = function getPinLeftCoordinate(popupRect, align, pinHeight, pinOffset) {
    switch (align) {
      case 'left':
        return pinOffset;

      case 'center':
        return popupRect.width / 2 - pinHeight;

      case 'right':
        return popupRect.width - pinOffset - 2 * pinHeight;

      default:
        throw new Error("Unexpected align '" + align + "'");
    }
  };

  return PopupPin;
}(React.Component);
PopupPin.__KONTUR_REACT_UI__ = 'PopupPin';
PopupPin.propTypes = {
  /**
   * Цвет фон пина
   */
  backgroundColor: PropTypes.string,

  /**
   * Цвет границы пина
   */
  borderColor: PropTypes.string,

  /**
   * Ширина границы пина
   */
  borderWidth: PropTypes.number,

  /**
   * Смещение пина от края попапа. Край задаётся в пропе position вторым словом
   */
  offset: PropTypes.number,

  /**
   * Ссылка на попап
   */
  popupElement: PropTypes.any,

  /**
   * Позиция поапа, по которой будет вычеслено положение пина
   */
  popupPosition: PropTypes.string,

  /**
   * Сторона пина без учёта границы.
   * Пин представляет собой равносторонний треугольник, высота от попапа
   * до "носика" пина будет соответствовать формуле (size* √3)/2
   */
  size: PropTypes.number
};