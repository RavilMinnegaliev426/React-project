"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.Tooltip = void 0;var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));var _react = _interopRequireDefault(require("react"));
var _warning = _interopRequireDefault(require("warning"));
var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _Popup = require("../../internal/Popup");
var _RenderLayer = require("../../internal/RenderLayer");
var _CrossIcon = require("../../internal/icons/CrossIcon");


var _listenFocusOutside = require("../../lib/listenFocusOutside");
var _ThemeContext = require("../../lib/theming/ThemeContext");


var _Tooltip = require("./Tooltip.styles");

var POPUP_MARGIN = 15;
var POPUP_PIN_OFFSET = 17;

var Positions = [
'right bottom',
'right middle',
'right top',
'top right',
'top center',
'top left',
'left top',
'left middle',
'left bottom',
'bottom left',
'bottom center',
'bottom right'];var

























































































































Tooltip = /*#__PURE__*/function (_React$PureComponent) {(0, _inheritsLoose2.default)(Tooltip, _React$PureComponent);function Tooltip() {var _this;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}_this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;_this.




























    state = { opened: false, focused: false };_this.
    theme = void 0;_this.
    hoverTimeout = null;_this.
    contentElement = null;_this.
    positions = null;_this.
    clickedOutside = true;_this.






























    renderContent = function () {
      var content = _this.props.render ? _this.props.render() : null;
      if (content == null) {
        return null;
      }

      return (
        _react.default.createElement("div", { ref: _this.refContent, className: _Tooltip.jsStyles.tooltipContent() },
        content,
        _this.renderCloseButton()));


    };_this.





















































    refContent = function (node) {
      _this.contentElement = node;
    };_this.





























































































    open = function () {return _this.setState({ opened: true });};_this.

    close = function () {return _this.setState({ opened: false });};_this.








    handleMouseEnter = function (event) {
      var isHoverAnchor = _this.props.trigger === 'hoverAnchor';
      if (isHoverAnchor && event.target === _this.contentElement) {
        return;
      }

      _this.clearHoverTimeout();

      _this.hoverTimeout = window.setTimeout(_this.open, Tooltip.delay);
    };_this.

    handleMouseLeave = function (event) {
      if (
      _this.props.trigger === 'hover&focus' && _this.state.focused ||
      _this.props.trigger === 'hover' && event.relatedTarget === _this.contentElement)
      {
        return;
      }

      _this.clearHoverTimeout();

      if (_this.props.trigger === 'hoverAnchor') {
        _this.close();
      } else {
        _this.hoverTimeout = window.setTimeout(_this.close, Tooltip.delay);
      }
    };_this.

    handleClick = function () {
      _this.open();
    };_this.

    handleClickOutsideAnchor = function (event) {
      _this.clickedOutside = _this.isClickOutsideContent(event);
      if (_this.clickedOutside) {
        if (_this.props.onCloseRequest) {
          _this.props.onCloseRequest();
        }
        _this.close();
      }
    };_this.









    handleFocus = function () {
      _this.setState({ focused: true });
      _this.open();
    };_this.

    handleBlur = function () {
      if (_this.props.trigger === 'hover&focus' && _this.clickedOutside) {
        _this.close();
      }

      if (_this.props.trigger === 'focus') {
        _this.close();
      }

      _this.clickedOutside = true;
      _this.setState({ focused: false });
    };_this.

    handleCloseButtonClick = function (event) {
      event.stopPropagation();

      if (_this.props.onCloseClick) {
        _this.props.onCloseClick(event);
      }

      if (event.defaultPrevented) {
        return;
      }

      if (_this.props.onCloseRequest) {
        _this.props.onCloseRequest();
      }

      _this.close();
    };return _this;}var _proto = Tooltip.prototype;_proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {if (nextProps.trigger === 'closed') {this.close();}var _this$props = this.props,allowedPositions = _this$props.allowedPositions,pos = _this$props.pos;var posChanged = nextProps.pos !== pos;var allowedChanged = !(0, _lodash.default)(nextProps.allowedPositions, allowedPositions);if (posChanged || allowedChanged) {this.positions = null;}};_proto.componentWillUnmount = function componentWillUnmount() {this.clearHoverTimeout();};_proto.render = function render() {var _this2 = this;return _react.default.createElement(_ThemeContext.ThemeContext.Consumer, null, function (theme) {_this2.theme = theme;return _this2.renderMain();});};_proto.renderCloseButton = function renderCloseButton() {var hasCross = this.props.closeButton === undefined ? !Tooltip.triggersWithoutCloseButton.includes(this.props.trigger) : this.props.closeButton;if (!hasCross) {return null;}return _react.default.createElement("div", { className: _Tooltip.jsStyles.cross(this.theme), onClick: this.handleCloseButtonClick }, _react.default.createElement(_CrossIcon.CrossIcon, null));};_proto.renderMain = function renderMain() {var props = this.props;var content = this.renderContent();var _this$getProps = this.getProps(),popupProps = _this$getProps.popupProps,_this$getProps$layerP = _this$getProps.layerProps,layerProps = _this$getProps$layerP === void 0 ? { active: false } : _this$getProps$layerP;var anchorElement = props.children || props.anchorElement;var popup = this.renderPopup(anchorElement, popupProps, content);return _react.default.createElement(_RenderLayer.RenderLayer, layerProps, popup);};_proto.renderPopup = function renderPopup(anchorElement, popupProps, content) {return _react.default.createElement(_Popup.Popup, (0, _extends2.default)({ anchorElement: anchorElement, hasPin: true, hasShadow: true, margin: POPUP_MARGIN, maxWidth: "none", opened: this.state.opened, pinOffset: POPUP_PIN_OFFSET, disableAnimations: this.props.disableAnimations, positions: this.getPositions(), ignoreHover: this.props.trigger === 'hoverAnchor', onOpen: this.props.onOpen }, popupProps), content);};_proto.getPositions = function getPositions() {if (!this.positions) {var allowedPositions = this.props.allowedPositions;var index = allowedPositions.indexOf(this.props.pos);if (index === -1) {throw new Error('Unexpected position passed to Tooltip. Expected one of: ' + allowedPositions.join(', '));}this.positions = [].concat(allowedPositions.slice(index), allowedPositions.slice(0, index));}return this.positions;};_proto.getProps = function getProps() {var props = this.props;var useWrapper = !!props.children && props.useWrapper;switch (props.trigger) {case 'opened':return { layerProps: { active: true, onClickOutside: this.handleClickOutsideAnchor }, popupProps: { opened: true, useWrapper: useWrapper } };case 'closed':return { popupProps: { opened: false, useWrapper: useWrapper } };case 'hoverAnchor':case 'hover':return { popupProps: { onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave, useWrapper: useWrapper } };case 'click':return { layerProps: { active: this.state.opened, onClickOutside: this.handleClickOutsideAnchor }, popupProps: { onClick: this.handleClick, useWrapper: useWrapper } };case 'focus':return { popupProps: { onFocus: this.handleFocus, onBlur: this.handleBlur, useWrapper: useWrapper } };case 'hover&focus':return { layerProps: { active: this.state.opened, onClickOutside: this.handleClickOutsideAnchor }, popupProps: { onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave, useWrapper: useWrapper } };default:throw new Error('Unknown trigger specified: ' + props.trigger);}};_proto.clearHoverTimeout = function clearHoverTimeout() {if (this.hoverTimeout) {clearTimeout(this.hoverTimeout);this.hoverTimeout = null;}};_proto.isClickOutsideContent = function isClickOutsideContent(event) {if (this.contentElement && event.target instanceof Element) {return !(0, _listenFocusOutside.containsTargetOrRenderContainer)(event.target)(this.contentElement);}return true;};return Tooltip;}(_react.default.PureComponent);exports.Tooltip = Tooltip;Tooltip.__KONTUR_REACT_UI__ = 'Tooltip';Tooltip.propTypes = { children: function children(props, propName, componentName) {var children = props[propName];(0, _warning.default)(children || props.anchorElement, "[" + componentName + "]: you must provide either 'children' or 'anchorElement' prop for " + componentName + " to work properly");(0, _warning.default)(!(Array.isArray(children) && props.useWrapper === false), "[" + componentName + "]: you provided multiple children, but useWrapper={false} - forcing wrapper <span/> for positioning to work correctly");} };Tooltip.defaultProps = { pos: 'top left', trigger: 'hover', allowedPositions: Positions, disableAnimations: Boolean(process.env.enableReactTesting), useWrapper: true, closeOnChildrenMouseLeave: false };Tooltip.delay = 100;Tooltip.triggersWithoutCloseButton = ['hover', 'hoverAnchor', 'focus', 'hover&focus'];