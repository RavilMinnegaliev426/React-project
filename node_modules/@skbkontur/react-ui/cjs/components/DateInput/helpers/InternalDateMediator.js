"use strict";exports.__esModule = true;exports.InternalDateMediator = void 0;var _InternalDate = require("../../../lib/date/InternalDate");
var _InternalDateGetter = require("../../../lib/date/InternalDateGetter");
var _InternalDateTransformer = require("../../../lib/date/InternalDateTransformer");
var _types = require("../../../lib/date/types");



var _inputNumber2 = require("./inputNumber");var

InternalDateMediator = /*#__PURE__*/function () {function InternalDateMediator() {var _this = this;this.
    iDate = new _InternalDate.InternalDate();this.

    update = function (props, locale) {
      var start = _this.iDate.getRangeStart();
      var min = start && start.toInternalString();
      var end = _this.iDate.getRangeEnd();
      var max = end && end.toInternalString();var
      order = locale.order,separator = locale.separator;
      _this.iDate.setOrder(order).setSeparator(separator);
      if (props.minDate !== min) {
        _this.iDate.setRangeStart(
        props.minDate ?
        new _InternalDate.InternalDate({
          order: order,
          separator: separator,
          value: props.minDate }) :

        null);

      }
      if (props.maxDate !== max) {
        _this.iDate.setRangeEnd(
        props.maxDate ?
        new _InternalDate.InternalDate({
          order: order,
          separator: separator,
          value: props.maxDate }) :

        null);

      }
      if (!props.value || props.value !== _this.iDate.toInternalString()) {
        _this.iDate.parseInternalValue(props.value);
      }
      return _this;
    };this.

















    paste = function (pasted) {
      _this.iDate.
      parseValue(pasted).
      restore().
      cutOffExcess();
      return _this;
    };this.

    restore = function () {
      if (_this.iDate.isIncomplete()) {
        var restored = _this.iDate.clone().restore();
        if (!_this.iDate.isEqual(restored)) {
          _this.iDate.duplicateOf(restored);
        }
        return true;
      }
      return false;
    };this.












































    getFragments = function () {return (
        _this.iDate.toFragments({
          withSeparator: true,
          withPad: true }));};this.


    deleteOneCharRight = function (type, inputMode) {
      var prev = _this.iDate.get(type);
      prev = String(inputMode ? prev : _InternalDateTransformer.InternalDateTransformer.padDateComponent(type, prev));
      var next = prev.replace(/.$/, '') || null;
      _this.iDate.set(type, next);
    };this.

    isChangedLocale = function (locale) {return (
        locale.order !== _this.iDate.getOrder() || locale.separator !== _this.iDate.getSeparator());};this.

    isNull = function (type) {return _this.iDate.get(type) === null;};this.

    isEmpty = function () {return _this.iDate.isEmpty();};this.

    get = function (type) {return _this.iDate.get(type);};this.

    clear = function (type) {return _this.iDate.set(type, null);};this.

    validateString = function (value) {return (
        _InternalDateTransformer.InternalDateTransformer.parseValueToDate(value, _this.iDate.getOrder()) !== null);};this.

    getString = function () {return _this.iDate.isEmpty() ? '' : _this.iDate.toString();};this.

    getInternalString = function () {return _this.iDate.isEmpty() ? '' : _this.iDate.toInternalString();};this.

    getTypesOrder = function () {return _this.iDate.toFragments().map(function (_ref) {var type = _ref.type;return type;});};this.

    getLeftmostType = function () {return _this.getTypesOrder()[0];};this.

    getRightmostType = function () {return _this.getTypesOrder()[2];};}var _proto = InternalDateMediator.prototype;_proto.inputKey = function inputKey(key, type, inputMode) {var prevValue = this.iDate.get(type);if (type === null) {type = this.getLeftmostType();this.clear(type);}if (type !== _types.InternalDateComponentType.Year) {this.iDate.cutOffExcess(type);} else {this.iDate.restore(type);}var _inputNumber = (0, _inputNumber2.inputNumber)(type, prevValue, key, inputMode),nextValue = _inputNumber.nextValue,nextInputMode = _inputNumber.nextInputMode;this.iDate.set(type, nextValue);return nextInputMode;};_proto.shiftDateComponent = function shiftDateComponent(type, step) {type = type === null ? this.getLeftmostType() : type;var iDate = this.iDate.clone();var isValidRange = iDate.validate({ checks: [_types.InternalDateValidateCheck.Range] });var start = iDate.getRangeStart();var end = iDate.getRangeEnd();if (!isValidRange) {// Удерживаем дату в заданном диапазоне
      if (start && _InternalDateGetter.InternalDateGetter.max([iDate, start]) === start) {iDate.duplicateOf(start);} else if (end && _InternalDateGetter.InternalDateGetter.min([iDate, end]) === end) {iDate.duplicateOf(end);}} else {var clone = iDate.clone().shift(type, step, { isRange: false, isLoop: true });if (clone.validate({ checks: [_types.InternalDateValidateCheck.Range] })) {iDate.duplicateOf(clone);}}var changed = !this.iDate.isEqualComponentDate(type, iDate);this.iDate = iDate;return changed;};_proto.getShiftedType = function getShiftedType(type, step) {var typesOrder = this.getTypesOrder();var index = type === null ? 0 : typesOrder.indexOf(type);var nextIndex = index + step; // Если выделено всё поле, то в завимости от направления перемещения, выделям крайний компонент
    if (type === _types.InternalDateComponentType.All) {return step < 0 ? typesOrder[0] : typesOrder[2];} // Если текущий компонент "год", и он не пуст, то при перемещении выделения "восстанавливаем" значение года
    if (type === _types.InternalDateComponentType.Year && this.iDate.getYear() !== null) {this.iDate.restore(type);}var shiftedType = typesOrder[nextIndex];return typeof shiftedType === 'number' ? shiftedType : type;};return InternalDateMediator;}();exports.InternalDateMediator = InternalDateMediator;