"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.isButton = exports.Button = void 0;var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));var _react = _interopRequireDefault(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));

var _utils = require("../../lib/utils");
var _tabListener = require("../../lib/events/tabListener");

var _ThemeContext = require("../../lib/theming/ThemeContext");

var _Button = require("./Button.styles");
var _Corners = require("./Corners");var































































































Button = /*#__PURE__*/function (_React$Component) {(0, _inheritsLoose2.default)(Button, _React$Component);function Button() {var _this;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}_this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;_this.













    state = {
      focusedByTab: false };_this.


    theme = void 0;_this.
    node = null;_this.
















































































































































































    handleFocus = function (e) {
      if (!_this.props.disabled && !_this.props.disableFocus) {
        // focus event fires before keyDown eventlistener
        // so we should check tabPressed in async way
        process.nextTick(function () {
          if (_tabListener.tabListener.isTabPressed) {
            _this.setState({ focusedByTab: true });
          }
        });
        _this.props.onFocus == null ? void 0 : _this.props.onFocus(e);
      }
    };_this.

    handleBlur = function (e) {
      _this.setState({ focusedByTab: false });
      if (!_this.props.disabled && !_this.props.disableFocus) {
        _this.props.onBlur == null ? void 0 : _this.props.onBlur(e);
      }
    };_this.

    _ref = function (node) {
      _this.node = node;
    };return _this;}var _proto = Button.prototype;_proto.componentDidMount = function componentDidMount() {if (this.props.autoFocus) {_tabListener.tabListener.isTabPressed = true;this.focus();}} /**
                                                                                                                                                                                                    * @public
                                                                                                                                                                                                    */;_proto.focus = function focus() {var _this$node;(_this$node = this.node) == null ? void 0 : _this$node.focus();} /**
                                                                                                                                                                                                                                                                                                                         * @public
                                                                                                                                                                                                                                                                                                                         */;_proto.blur = function blur() {var _this$node2;(_this$node2 = this.node) == null ? void 0 : _this$node2.blur();};_proto.render = function render() {var _this2 = this;return _react.default.createElement(_ThemeContext.ThemeContext.Consumer, null, function (theme) {_this2.theme = theme;return _this2.renderMain();});};_proto.renderMain = function renderMain() {var _cn, _cn2;var _this$props$corners = this.props.corners,corners = _this$props$corners === void 0 ? 0 : _this$props$corners;var sizeClass = this.getSizeClassName();var isError = !!this.props.error;var isWarning = !!this.props.warning;var rootProps = { // By default the type attribute is 'submit'. IE8 will fire a click event
      // on this button if somewhere on the page user presses Enter while some
      // input is focused. So we set type to 'button' by default.
      type: this.props.type, className: (0, _classnames.default)((_cn = {}, _cn[_Button.jsStyles.root(this.theme)] = true, _cn[_Button.jsStyles[this.props.use] && _Button.jsStyles[this.props.use](this.theme) || _Button.jsStyles.default(this.theme)] = true, _cn[_Button.jsStyles.active(this.theme)] = !!this.props.active, _cn[_Button.jsStyles.validationRoot(this.theme)] = isError || isWarning, _cn[_Button.jsStyles.error(this.theme)] = isError, _cn[_Button.jsStyles.warning(this.theme)] = isWarning, _cn[_Button.jsStyles.narrow()] = !!this.props.narrow, _cn[_Button.jsStyles.noPadding()] = !!this.props._noPadding, _cn[_Button.jsStyles.noRightPadding()] = !!this.props._noRightPadding, _cn[_Button.jsStyles.buttonWithIcon()] = !!this.props.icon, _cn[sizeClass] = true, _cn[_Button.jsStyles.borderless(this.theme)] = !!this.props.borderless, _cn[_Button.jsStyles.focus(this.theme)] = this.state.focusedByTab || !!this.props.visuallyFocused, _cn[_Button.jsStyles.checked(this.theme)] = !!this.props.checked && !this.props.disabled, _cn[_Button.jsStyles.disabled(this.theme)] = !!this.props.disabled || !!this.props.loading, _cn[_Button.jsStyles.fallback(this.theme)] = _utils.isIE11 || _utils.isEdge, _cn)), style: { borderTopLeftRadius: corners & _Corners.Corners.TOP_LEFT ? 0 : undefined, borderTopRightRadius: corners & _Corners.Corners.TOP_RIGHT ? 0 : undefined, borderBottomRightRadius: corners & _Corners.Corners.BOTTOM_RIGHT ? 0 : undefined, borderBottomLeftRadius: corners & _Corners.Corners.BOTTOM_LEFT ? 0 : undefined, textAlign: this.props.align }, disabled: this.props.disabled || this.props.loading, onClick: this.props.onClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.props.onKeyDown, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave, onMouseOver: this.props.onMouseOver, tabIndex: this.props.disableFocus ? -1 : 0 };var wrapProps = { className: (0, _classnames.default)((_cn2 = {}, _cn2[_Button.jsStyles.wrap(this.theme)] = true, _cn2[_Button.jsStyles.wrapArrow()] = this.props.arrow === true, _cn2[_Button.jsStyles.wrapArrowLeft()] = this.props.arrow === 'left', _cn2)), style: { width: this.props.width } };var error = null;if (this.props.error) {error = _react.default.createElement("div", { className: _Button.jsStyles.error(this.theme) });} else if (this.props.warning) {error = _react.default.createElement("div", { className: _Button.jsStyles.warning(this.theme) });}var loading = null;if (this.props.loading) {loading = _react.default.createElement("div", { className: _Button.jsStyles.loading() });}var icon = this.props.icon;if (this.props.icon) {icon = _react.default.createElement("span", { className: _Button.jsStyles.icon() }, this.props.icon);}var arrow = null;if (this.props.arrow) {var _cn3;arrow = _react.default.createElement("div", { className: (0, _classnames.default)((_cn3 = {}, _cn3[_Button.jsStyles.arrowWarning(this.theme)] = isWarning, _cn3[_Button.jsStyles.arrowError(this.theme)] = isError, _cn3[_Button.jsStyles.arrow()] = true, _cn3[_Button.jsStyles.arrowLeft(this.theme)] = this.props.arrow === 'left', _cn3)) });} // Force disable all props and features, that cannot be use with Link
    if (this.props.use === 'link') {var _cn4, _cn5;rootProps.className = (0, _classnames.default)((_cn4 = {}, _cn4[_Button.jsStyles.root(this.theme)] = true, _cn4[_Button.jsStyles.buttonWithIcon()] = !!this.props.icon, _cn4[sizeClass] = true, _cn4[_Button.jsStyles.focus(this.theme)] = this.state.focusedByTab || !!this.props.visuallyFocused, _cn4[_Button.jsStyles.link(this.theme)] = true, _cn4[_Button.jsStyles.disabled(this.theme)] = !!this.props.disabled, _cn4));Object.assign(wrapProps, { className: (0, _classnames.default)(_Button.jsStyles.wrap(this.theme), (_cn5 = {}, _cn5[_Button.jsStyles.wrapLink(this.theme)] = this.props.use === 'link', _cn5)), style: { width: wrapProps.style.width } });rootProps.style.textAlign = undefined;loading = null;arrow = null;}return _react.default.createElement("span", wrapProps, _react.default.createElement("button", (0, _extends2.default)({ ref: this._ref }, rootProps), error, loading, arrow, _react.default.createElement("div", { className: _Button.jsStyles.caption() }, icon, this.props.children)));};_proto.getSizeClassName = function getSizeClassName() {var _cn6, _cn7, _cn8;switch (this.props.size) {case 'large':return (0, _classnames.default)(_Button.jsStyles.sizeLarge(this.theme), (_cn6 = {}, _cn6[_Button.jsStyles.sizeLargeLoading(this.theme)] = this.props.loading, _cn6));case 'medium':return (0, _classnames.default)(_Button.jsStyles.sizeMedium(this.theme), (_cn7 = {}, _cn7[_Button.jsStyles.sizeMediumLoading(this.theme)] = this.props.loading, _cn7));case 'small':default:return (0, _classnames.default)(_Button.jsStyles.sizeSmall(this.theme), (_cn8 = {}, _cn8[_Button.jsStyles.sizeSmallLoading(this.theme)] = this.props.loading, _cn8));}};return Button;}(_react.default.Component);exports.Button = Button;Button.__KONTUR_REACT_UI__ = 'Button';Button.__BUTTON__ = true;Button.TOP_LEFT = _Corners.Corners.TOP_LEFT;Button.TOP_RIGHT = _Corners.Corners.TOP_RIGHT;Button.BOTTOM_RIGHT = _Corners.Corners.BOTTOM_RIGHT;Button.BOTTOM_LEFT = _Corners.Corners.BOTTOM_LEFT;Button.defaultProps = { use: 'default', size: 'small', type: 'button' };var isButton = function isButton(child) {return _react.default.isValidElement(child) ? Object.prototype.hasOwnProperty.call(child.type, '__BUTTON__') : false;};exports.isButton = isButton;