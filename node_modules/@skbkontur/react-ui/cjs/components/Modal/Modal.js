"use strict";var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.Modal = void 0;var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));var _react = _interopRequireDefault(require("react"));
var _reactFocusLock = _interopRequireDefault(require("react-focus-lock"));
var _classnames = _interopRequireDefault(require("classnames"));

var _identifiers = require("../../lib/events/keyboard/identifiers");
var LayoutEvents = _interopRequireWildcard(require("../../lib/LayoutEvents"));
var _RenderContainer = require("../../internal/RenderContainer");
var _ZIndex = require("../../internal/ZIndex");
var _stopPropagation = require("../../lib/events/stopPropagation");
var _HideBodyVerticalScroll = require("../../internal/HideBodyVerticalScroll");
var _ModalStack = require("../../lib/ModalStack");
var _ResizeDetector = require("../../internal/ResizeDetector");
var _ThemeContext = require("../../lib/theming/ThemeContext");

var _utils = require("../../lib/utils");

var _ModalContext = require("./ModalContext");
var _ModalFooter = require("./ModalFooter");
var _ModalHeader = require("./ModalHeader");
var _helpers = require("./helpers");
var _ModalBody = require("./ModalBody");
var _ModalClose = require("./ModalClose");
var _Modal = require("./Modal.styles");

var mountedModalsCount = 0;









































/**
                             * Модальное окно
                             *
                             * Содержит в себе три компоненты: **Modal.Header**,
                             * **Modal.Body** и **Modal.Footer**
                             *
                             * Для отображения серой плашки в футере в компонент
                             * **Footer** необходимо передать пропс **panel**
                             *
                             * Для отключения прилипания шапки и футера
                             * в соответствующий компонет нужно передать
                             * проп **sticky** со значением **false**
                             * (по-умолчанию прилипание включено)
                             */var
Modal = /*#__PURE__*/function (_React$Component) {(0, _inheritsLoose2.default)(Modal, _React$Component);function Modal() {var _this;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}_this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;_this.























    state = {
      stackPosition: 0,
      horizontalScroll: false };_this.


    theme = void 0;_this.
    stackSubscription = null;_this.
    containerNode = null;_this.
    mouseDownTarget = null;_this.
    mouseUpTarget = null;_this.
































































































































    requestClose = function () {
      if (_this.props.disableClose) {
        return;
      }
      if (_this.props.onClose) {
        _this.props.onClose();
      }
    };_this.

    refContainer = function (center) {
      _this.containerNode = center;
    };_this.

    handleStackChange = function (stack) {
      _this.setState({ stackPosition: stack.indexOf((0, _assertThisInitialized2.default)(_this)) });
    };_this.

    handleContainerMouseDown = function (event) {
      _this.mouseDownTarget = event.target;
    };_this.

    handleContainerMouseUp = function (event) {
      _this.mouseUpTarget = event.target;
    };_this.

    handleContainerClick = function (event) {
      if (!_this.props.ignoreBackgroundClick) {var
        target = event.target,currentTarget = event.currentTarget;
        if (target === currentTarget && _this.mouseDownTarget === currentTarget && _this.mouseUpTarget === currentTarget) {
          _this.requestClose();
        }
      }
    };_this.

    handleKeyDown = function (e) {
      if (_this.state.stackPosition !== 0) {
        return;
      }
      if ((0, _identifiers.isKeyEscape)(e)) {
        (0, _stopPropagation.stopPropagation)(e);
        _this.requestClose();
      }
    };_this.

    checkHorizontalScrollAppearance = function () {
      var hasScroll = false;

      if (_this.containerNode) {
        var containerClientWidth = _this.containerNode.clientWidth;
        var containerScrollWidth = _this.containerNode.scrollWidth;
        hasScroll = containerClientWidth < containerScrollWidth;
      }
      if (hasScroll && !_this.state.horizontalScroll) {
        _this.setState({ horizontalScroll: true });
      } else if (_this.state.horizontalScroll) {
        _this.setState({ horizontalScroll: false });
      }
    };_this.

    handleResize = function (event) {
      LayoutEvents.emit();
    };return _this;}var _proto = Modal.prototype;_proto.componentDidMount = function componentDidMount() {this.stackSubscription = _ModalStack.ModalStack.add(this, this.handleStackChange);if (mountedModalsCount === 0) {window.addEventListener('resize', this.checkHorizontalScrollAppearance);}mountedModalsCount++;window.addEventListener('keydown', this.handleKeyDown);this.checkHorizontalScrollAppearance();if (this.containerNode) {this.containerNode.addEventListener('scroll', LayoutEvents.emit);}};_proto.componentWillUnmount = function componentWillUnmount() {if (--mountedModalsCount === 0) {window.removeEventListener('resize', this.checkHorizontalScrollAppearance);LayoutEvents.emit();}window.removeEventListener('keydown', this.handleKeyDown);if (this.stackSubscription != null) {this.stackSubscription.remove();}_ModalStack.ModalStack.remove(this);if (this.containerNode) {this.containerNode.removeEventListener('scroll', LayoutEvents.emit);}};_proto.render = function render() {var _this2 = this;return _react.default.createElement(_ThemeContext.ThemeContext.Consumer, null, function (theme) {_this2.theme = theme;return _this2.renderMain();});};_proto.renderMain = function renderMain() {var _cn;var hasHeader = false;var hasFooter = false;var hasPanel = false;_react.default.Children.toArray(this.props.children).forEach(function (child) {if ((0, _helpers.isHeader)(child)) {hasHeader = true;}if ((0, _helpers.isFooter)(child)) {hasFooter = true;if (child.props.panel) {hasPanel = true;}}});var modalContextProps = { hasHeader: hasHeader, horizontalScroll: this.state.horizontalScroll };if (hasHeader && !this.props.noClose) {modalContextProps.close = { disableClose: this.props.disableClose, requestClose: this.requestClose };}if (!hasFooter) {modalContextProps.additionalPadding = true;}if (hasFooter && hasPanel) {modalContextProps.additionalPadding = true;}var style = {};var containerStyle = {};if (this.props.width) {style.width = this.props.width;} else {containerStyle.width = 'auto';}return _react.default.createElement(_RenderContainer.RenderContainer, null, _react.default.createElement(_ZIndex.ZIndex, { priority: 'Modal', className: _Modal.jsStyles.root() }, _react.default.createElement(_HideBodyVerticalScroll.HideBodyVerticalScroll, null), this.state.stackPosition === 0 && _react.default.createElement("div", { className: _Modal.jsStyles.bg(this.theme) }), _react.default.createElement("div", { ref: this.refContainer, className: _Modal.jsStyles.container(), onMouseDown: this.handleContainerMouseDown, onMouseUp: this.handleContainerMouseUp, onClick: this.handleContainerClick, "data-tid": "modal-container" }, _react.default.createElement("div", { className: (0, _classnames.default)((_cn = {}, _cn[_Modal.jsStyles.centerContainer(this.theme)] = true, _cn[_Modal.jsStyles.alignTop(this.theme)] = Boolean(this.props.alignTop), _cn)), style: containerStyle, "data-tid": "modal-content" }, _react.default.createElement("div", { className: _Modal.jsStyles.window(this.theme), style: style }, _react.default.createElement(_ResizeDetector.ResizeDetector, { onResize: this.handleResize }, _react.default.createElement(_reactFocusLock.default, { disabled: this.props.disableFocusLock, autoFocus: false }, !hasHeader && !this.props.noClose ? _react.default.createElement(_ZIndex.ZIndex, { priority: 'ModalCross', className: _Modal.jsStyles.closeWrapper() }, _react.default.createElement(_ModalClose.ModalClose, { requestClose: this.requestClose, disableClose: this.props.disableClose })) : null, _react.default.createElement(_ModalContext.ModalContext.Provider, { value: modalContextProps }, this.props.children))))))));};return Modal;}(_react.default.Component);exports.Modal = Modal;Modal.__KONTUR_REACT_UI__ = 'Modal';Modal.Header = _ModalHeader.ModalHeader;Modal.Body = _ModalBody.ModalBody;Modal.Footer = _ModalFooter.ModalFooter;Modal.propTypes = { children: function children(props, propName, componentName) {if (_react.default.Children.toArray(props[propName]).some(function (child) {return !(0, _helpers.isHeader)(child) && !(0, _helpers.isBody)(child) && !(0, _helpers.isFooter)(child);})) {return new Error("Only 'Header/Body/Footer' components are allowed for '" + propName + "' prop of '" + componentName + "' component");}} };Modal.defaultProps = { // NOTE: в ie нормально не работает
  disableFocusLock: _utils.isIE11 };