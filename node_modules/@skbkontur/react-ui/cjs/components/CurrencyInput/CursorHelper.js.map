{"version":3,"sources":["CursorHelper.tsx"],"names":["CursorHelper","normalizePosition","map","position","Math","min","max","length","calculatePosition","step","Error","raw","toRawPosition","toFormattedPosition","extendSelection","selection","normalizeSelection","direction","start","end","formattedPosition","count","Set","slice","size","rawPosition","unique","add"],"mappings":"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","sourcesContent":["import { Selection } from './SelectionHelper';\r\n\r\nexport type CursorMap = number[];\r\n\r\nexport class CursorHelper {\r\n  public static normalizePosition(map: CursorMap, position: number): number {\r\n    return map[Math.min(Math.max(0, position), map.length - 1)];\r\n  }\r\n\r\n  public static calculatePosition(map: CursorMap, position: number, step: number) {\r\n    if (position < 0 || map.length <= position) {\r\n      throw new Error(`position out of range [${0} .. ${map.length - 1}], actual value: ${position}`);\r\n    }\r\n    const raw = CursorHelper.toRawPosition(map, position);\r\n    return CursorHelper.toFormattedPosition(map, raw + step);\r\n  }\r\n\r\n  public static extendSelection(map: CursorMap, selection: Selection, step: number) {\r\n    selection = CursorHelper.normalizeSelection(map, selection);\r\n\r\n    selection =\r\n      selection.direction === 'backward'\r\n        ? {\r\n            start: CursorHelper.calculatePosition(map, selection.start, step),\r\n            end: selection.end,\r\n            direction: 'backward',\r\n          }\r\n        : {\r\n            start: selection.start,\r\n            end: CursorHelper.calculatePosition(map, selection.end, step),\r\n            direction: 'forward',\r\n          };\r\n\r\n    return CursorHelper.normalizeSelection(map, selection);\r\n  }\r\n\r\n  public static normalizeSelection(map: CursorMap, selection: Selection): Selection {\r\n    const start = CursorHelper.normalizePosition(map, selection.start);\r\n    const end = CursorHelper.normalizePosition(map, selection.end);\r\n\r\n    if (start === end) {\r\n      return {\r\n        start,\r\n        end,\r\n        direction: 'none',\r\n      };\r\n    }\r\n\r\n    if (start < end) {\r\n      return {\r\n        start,\r\n        end,\r\n        direction: selection.direction === 'backward' ? 'backward' : 'forward',\r\n      };\r\n    }\r\n\r\n    return {\r\n      start: end,\r\n      end: start,\r\n      direction: selection.direction === 'backward' ? 'forward' : 'backward',\r\n    };\r\n  }\r\n\r\n  public static toRawPosition(map: CursorMap, formattedPosition: number) {\r\n    const count = Math.min(Math.max(0, formattedPosition), map.length - 1);\r\n    return new Set(map.slice(0, count + 1)).size - 1;\r\n  }\r\n\r\n  public static toFormattedPosition(map: CursorMap, rawPosition: number) {\r\n    const count = Math.max(0, rawPosition) + 1;\r\n    const unique = new Set();\r\n\r\n    for (const position of map) {\r\n      unique.add(position);\r\n      if (unique.size === count) {\r\n        return position;\r\n      }\r\n    }\r\n\r\n    return map[map.length - 1];\r\n  }\r\n}\r\n"]}