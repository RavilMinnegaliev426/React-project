"use strict";var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.reducer = reducer;exports.Effect = void 0;var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _lodash = _interopRequireDefault(require("lodash.debounce"));
var _lodash2 = _interopRequireDefault(require("lodash.isequal"));

var _identifiers = require("../../lib/events/keyboard/identifiers");
var LayoutEvents = _interopRequireWildcard(require("../../lib/LayoutEvents"));


var _CustomComboBox = require("./CustomComboBox");
var _CustomComboBoxTypes = require("./CustomComboBoxTypes");























































var DEBOUNCE_DELAY = 300;

var getValueString = function getValueString(value, valueToString) {
  return value ? valueToString(value) : '';
};

var Effect = {
  Search: function Search(query) {return function (dispatch, getState, getProps, getInstance) {
      getInstance().search(query);
    };},
  DebouncedSearch: (0, _lodash.default)(function (dispatch, getState, getProps, getInstance) {
    var searchEffect = Effect.Search(getState().textValue);
    searchEffect(dispatch, getState, getProps, getInstance);
  }, DEBOUNCE_DELAY),
  CancelRequest: function CancelRequest(dispatch, getState, getProps, getInstance) {
    Effect.DebouncedSearch.cancel();
    getInstance().cancelSearch();
  },
  Blur: function Blur(dispatch, getState, getProps) {var _getProps =
    getProps(),onBlur = _getProps.onBlur;
    if (onBlur) {
      onBlur();
    }
  },
  Focus: function Focus(dispatch, getState, getProps) {var _getProps2 =
    getProps(),onFocus = _getProps2.onFocus;
    if (onFocus) {
      onFocus();
    }
  },
  ValueChange: function ValueChange(value) {return function (dispatch, getState, getProps) {var _getProps3 =
      getProps(),onValueChange = _getProps3.onValueChange;
      if (onValueChange) {
        onValueChange(value);
      }
    };},
  UnexpectedInput: function UnexpectedInput(textValue, items) {return function (dispatch, getState, getProps) {var _getProps4 =
      getProps(),onUnexpectedInput = _getProps4.onUnexpectedInput,valueToString = _getProps4.valueToString;

      if (Array.isArray(items) && items.length === 1) {
        var singleItem = items[0];
        var valueContent = getValueString(singleItem, valueToString);

        if (valueContent === textValue) {
          dispatch({ type: 'ValueChange', value: singleItem, keepFocus: false });
          return;
        }
      }

      if (onUnexpectedInput) {
        var _value = onUnexpectedInput(textValue);
        if (_value !== undefined) {
          dispatch({ type: 'ValueChange', value: _value, keepFocus: false });
        }
      }
    };},
  InputChange: function InputChange(dispatch, getState, getProps) {var _getProps5 =
    getProps(),onInputValueChange = _getProps5.onInputValueChange;var _getState =
    getState(),textValue = _getState.textValue;
    if (onInputValueChange) {
      var returnedValue = onInputValueChange(textValue);
      if (typeof returnedValue === 'string' && returnedValue !== textValue) {
        dispatch({ type: 'TextChange', value: returnedValue });
      }
    }
  },
  InputFocus: function InputFocus(dispatch, getState, getProps, getInstance) {var _getInstance =
    getInstance(),input = _getInstance.input;

    if (!input) {
      return;
    }

    input.focus();
  },
  HighlightMenuItem: function HighlightMenuItem(dispatch, getState, getProps, getInstance) {var _getProps6 =
    getProps(),value = _getProps6.value,itemToValue = _getProps6.itemToValue,valueToString = _getProps6.valueToString;var _getState2 =
    getState(),items = _getState2.items,focused = _getState2.focused,textValue = _getState2.textValue,requestStatus = _getState2.requestStatus;var _getInstance2 =
    getInstance(),menu = _getInstance2.menu;
    var valueString = getValueString(value, valueToString);

    if (!menu) {
      return;
    }

    if (!focused) {
      return;
    }

    var index = -1;
    if (items && items.length && value) {
      index = items.findIndex(function (x) {return itemToValue(x) === itemToValue(value);});
    }
    menu.highlightItem(index);

    if (index >= 0) {
      // FIXME: accessing private props
      // @ts-ignore
      process.nextTick(function () {return menu && menu.scrollToSelected();});
      return;
    }

    if (textValue !== valueString || requestStatus === _CustomComboBoxTypes.ComboBoxRequestStatus.Failed) {
      process.nextTick(function () {return menu && menu.down();});
    }
  },
  SelectMenuItem: function SelectMenuItem(event) {return function (dispatch, getState, getProps, getInstance) {var _getInstance3 =
      getInstance(),menu = _getInstance3.menu;
      if (menu) {
        menu.enter(event);
      }
    };},
  MoveMenuHighlight: function MoveMenuHighlight(direction) {return function (dispatch, getState, getProps, getInstance) {var _getInstance4 =
      getInstance(),menu = _getInstance4.menu;
      if (menu) {
        menu[direction]();
      }
    };},
  ResetHighlightedMenuItem: function ResetHighlightedMenuItem(dispatch, getState, getProps, getInstance) {
    var combobox = getInstance();

    if (combobox.menu && combobox.menu.hasHighlightedItem()) {
      combobox.menu.reset();
    }
  },
  Reflow: function Reflow() {
    LayoutEvents.emit();
  },
  SelectInputText: function SelectInputText(dispatch, getState, getProps, getInstance) {
    var combobox = getInstance();
    combobox.selectInputText();
  },
  InputKeyDown: function InputKeyDown(event) {return function (dispatch, getState, getProps, getInstance) {var _getProps7 =
      getProps(),onInputKeyDown = _getProps7.onInputKeyDown;
      if (onInputKeyDown) {
        onInputKeyDown(event);
      }
    };} };exports.Effect = Effect;


var never = function never(_) {return null;};

function reducer(
state,
props,
action)
{
  switch (action.type) {
    case 'ValueChange':{var
        _value2 = action.value,keepFocus = action.keepFocus;
        var _textValue = getValueString(_value2, props.valueToString);
        if (keepFocus) {
          return [
          {
            opened: false,
            inputChanged: false,
            editing: true,
            items: null,
            textValue: _textValue },

          [Effect.ValueChange(_value2), Effect.CancelRequest, Effect.InputFocus]];

        }
        return [
        {
          opened: false,
          inputChanged: false,
          editing: false,
          items: null,
          textValue: _textValue },

        [Effect.ValueChange(_value2), Effect.CancelRequest]];

      }
    case 'TextChange':{
        var newState = {
          inputChanged: true,
          textValue: action.value };

        if (!action.value && !props.searchOnFocus) {
          return [(0, _extends2.default)({},

          newState, {
            opened: false,
            items: null }),

          [Effect.InputChange]];

        }
        return [newState, [Effect.DebouncedSearch, Effect.InputChange]];
      }
    case 'KeyPress':{
        var e = action.event;
        var effects = [];
        var nextState = state;

        switch (true) {
          case (0, _identifiers.isKeyEnter)(e):
            e.preventDefault();
            effects.push(Effect.SelectMenuItem(e));
            break;
          case (0, _identifiers.isKeyArrowVertical)(e):
            e.preventDefault();
            effects.push(Effect.MoveMenuHighlight((0, _identifiers.isKeyArrowUp)(e) ? 'up' : 'down'));
            if (!state.opened) {
              effects.push(Effect.Search(state.textValue));
            }
            break;
          case (0, _identifiers.isKeyEscape)(e):
            nextState = (0, _extends2.default)({},
            state, {
              items: null,
              opened: false });

            break;}

        return [nextState, [].concat(effects, [Effect.InputKeyDown(e)])];
      }
    case 'DidUpdate':{
        if ((0, _lodash2.default)(props.value, action.prevProps.value)) {
          return state;
        }

        return {
          opened: false,
          textValue: state.editing ? state.textValue : getValueString(props.value, props.valueToString) };

      }
    case 'Mount':{
        return {
          textValue: getValueString(props.value, props.valueToString) };

      }
    case 'Focus':{
        var _newState = {
          focused: true,
          editing: true };

        if (!props.searchOnFocus) {
          return [_newState, [Effect.Focus]];
        }
        if (state.editing) {
          return [_newState, [Effect.Search(state.textValue), Effect.Focus]];
        }
        return [_newState, [Effect.Search(''), Effect.Focus, Effect.SelectInputText]];
      }
    case 'InputClick':{
        if (!state.opened && props.searchOnFocus) {
          return [state, [Effect.Search('')]];
        }
        return state;
      }
    case 'Blur':{var
        inputChanged = state.inputChanged,_items = state.items;
        if (!inputChanged) {
          return [
          {
            focused: false,
            opened: false,
            items: null,
            editing: false },

          [Effect.Blur, Effect.CancelRequest]];

        }

        return [
        {
          focused: false,
          opened: false,
          items: null },

        [Effect.Blur, Effect.CancelRequest, Effect.UnexpectedInput(state.textValue, _items)]];

      }
    case 'Reset':{
        return _CustomComboBox.DefaultState;
      }
    case 'Open':{
        return { opened: true };
      }
    case 'Close':{
        return { opened: false, items: null };
      }
    case 'Search':{
        return [state, [Effect.Search(action.query)]];
      }
    case 'RequestItems':{
        return {
          loading: true,
          opened: true,
          requestStatus: _CustomComboBoxTypes.ComboBoxRequestStatus.Pending };

      }
    case 'ReceiveItems':{
        var shouldResetMenuHighlight = state.textValue === '';
        return [
        {
          loading: false,
          opened: true,
          items: action.items,
          requestStatus: _CustomComboBoxTypes.ComboBoxRequestStatus.Success },

        [shouldResetMenuHighlight ? Effect.ResetHighlightedMenuItem : Effect.HighlightMenuItem, Effect.Reflow]];

      }
    case 'RequestFailure':{
        return [
        {
          loading: false,
          opened: true,
          items: null,
          requestStatus: _CustomComboBoxTypes.ComboBoxRequestStatus.Failed,
          repeatRequest: action.repeatRequest },

        [Effect.HighlightMenuItem]];

      }
    case 'CancelRequest':{
        return {
          loading: false,
          requestStatus: _CustomComboBoxTypes.ComboBoxRequestStatus.Unknown };

      }
    default:{
        never(action);
      }}

  return state;
}