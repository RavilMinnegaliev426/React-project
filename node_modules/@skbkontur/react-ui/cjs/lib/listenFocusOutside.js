"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.containsTargetOrRenderContainer = containsTargetOrRenderContainer;exports.listen = listen;var _reactDom = _interopRequireDefault(require("react-dom"));
var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _utils = require("./utils");






var handlers = [];

function addHandleEvent() {
  /**
                            * Firefox do not supports 'focusin' event.
                            * Focus events bubbles multiple time
                            * without possibilty to cancell bubbling.
                            * Using debounce to capture only first focus event
                            * Mozilla Firefix
                            *   ¯\_(ツ)_/¯
                            */
  document.body.addEventListener(
  _utils.isFirefox ? 'focus' : 'focusin',
  _utils.isFirefox ? (0, _lodash.default)(handleNativeFocus, 0, { leading: true, trailing: false }) : handleNativeFocus,
  _utils.isFirefox);

}

if (typeof document !== 'undefined') {
  if (document.readyState === 'complete') {
    addHandleEvent();
  } else {
    window.addEventListener('load', addHandleEvent);
  }
}

function handleNativeFocus(event) {
  // FIXME: not safe casting
  var target = event.target || event.srcElement;

  handlers.forEach(function (handler) {
    var elements = handler.elements;
    if (typeof elements === 'function') {
      elements = elements();
    }

    if (elements.some(containsTargetOrRenderContainer(target))) {
      return;
    }
    _reactDom.default.unstable_batchedUpdates(function () {return handler.callback(event);});
  });
}

function containsTargetOrRenderContainer(target) {
  return function (element) {
    if (!element) {
      return false;
    }
    if (element.contains(target)) {
      return true;
    }
    var container = findRenderContainer(target, element);
    return !!container && element.contains(container);
  };
}

/**
   * Searches RenderContainer placed in "rootNode" for "node"
   */
function findRenderContainer(node, rootNode, container) {
  var currentNode = node.parentNode;
  if (
  !currentNode ||
  node === rootNode ||
  currentNode === rootNode ||
  currentNode === document.body ||
  currentNode === document.documentElement ||
  !(currentNode instanceof Element))
  {
    return container ? container : null;
  }

  var newContainerId = currentNode.getAttribute('data-rendered-container-id');
  if (newContainerId) {
    var nextNode = document.querySelector("[data-render-container-id~=\"" + newContainerId + "\"]");

    if (!nextNode) {
      throw Error("Origin node for container with id " + newContainerId + " was not found");
    }

    return findRenderContainer(nextNode, rootNode, nextNode);
  }

  return findRenderContainer(currentNode, rootNode, container);
}

function listen(elements, callback) {
  var handler = {
    elements: elements,
    callback: callback };

  handlers.push(handler);

  return {
    remove: function remove() {
      var index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    } };

}