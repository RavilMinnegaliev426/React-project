import _extends from "@babel/runtime/helpers/esm/extends";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";

var _dec, _class, _class2, _temp;

import React from 'react';
import { Gapped } from "../../../Gapped";
import { Button } from "../../../Button";
import { locale } from "../../../../lib/locale/decorators";
import { FiasLocaleHelper } from "../../locale";
import { FiasExtraFields, FiasFields, FiasFormValidation } from "../../types";
import { FiasAddressElement } from "../../models/FiasAddressElement";
import { Tooltip } from "../../../Tooltip";
import { Input } from "../../../Input";
import { FiasSearch } from "../../FiasSearch/FiasSearch";
import { Textarea } from "../../../Textarea";
import { FiasAddress } from "../../models/FiasAddress";
import { FiasCountrySelector } from "../FiasCountrySelector";
import { jsStyles } from "../FiasForm.styles";
import { FiasComboBox } from "../FiasComboBox";
export var FiasForm = (_dec = locale('Fias', FiasLocaleHelper), _dec(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(FiasForm, _React$Component);

  function FiasForm(_props) {
    var _this;

    _this = _React$Component.call(this, _props) || this;
    _this.state = {
      address: _this.props.address
    };
    _this.locale = void 0;
    _this.fields = void 0;
    _this.lastVerifyPromise = null;
    _this.submit =
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee() {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.lastVerifyPromise;

            case 2:
              return _context.abrupt("return", _this.state.address);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    _this.getCommonFieldProps = function (field) {
      var address = _this.state.address;
      var validationLevel = _this.props.validationLevel;
      return {
        error: address.hasError(field) && validationLevel === FiasFormValidation.Error,
        warning: address.hasError(field) && validationLevel === FiasFormValidation.Warning,
        placeholder: _this.locale[field + "Placeholder"]
      };
    };

    _this.renderFields = function (fields) {
      var fieldsSettings = _this.props.fieldsSettings;
      return fields.map(function (field) {
        var control = _this.fields[field];
        var settings = fieldsSettings[field];

        if (control && Boolean(settings && settings.visible)) {
          var meta = control.meta,
              render = control.render;
          var label = _this.locale[field + "Label"];
          return control && React.createElement(FiasForm.Field, {
            label: label,
            key: field
          }, React.createElement(Tooltip, {
            pos: 'right middle',
            render: meta.tooltip
          }, render()));
        }
      });
    };

    _this.renderAddressComboBox = function (field, width) {
      if (width === void 0) {
        width = '100%';
      }

      var comboboxField = _this.fields[field];

      if (comboboxField && FiasForm.isComboboxMeta(comboboxField.meta)) {
        var address = _this.state.address;
        var _comboboxField$meta = comboboxField.meta,
            props = _comboboxField$meta.props,
            createRef = _comboboxField$meta.createRef;

        var commonProps = _this.getCommonFieldProps(field);

        return React.createElement(FiasComboBox, _extends({}, commonProps, props, {
          value: address,
          width: width,
          drawArrow: false,
          searchOnFocus: false,
          limit: _this.props.limit,
          ref: createRef
        }));
      }
    };

    _this.renderPostalCodeInput = function () {
      var inputField = _this.fields[FiasExtraFields.postalcode];

      if (inputField && FiasForm.isInputMeta(inputField.meta)) {
        var address = _this.state.address;
        var _inputField$meta = inputField.meta,
            props = _inputField$meta.props,
            createRef = _inputField$meta.createRef;

        var commonProps = _this.getCommonFieldProps(FiasExtraFields.postalcode);

        var value = address.postalCode;
        return React.createElement(Input, _extends({}, commonProps, props, {
          value: value,
          width: 130,
          ref: createRef
        }));
      }
    };

    _this.createAddressComboboxMeta = function (field) {
      return {
        ref: null,
        props: _this.createAddressComboBoxProps(field),
        tooltip: _this.createAddressComboBoxTooltip(field),
        createRef: function createRef(ref) {
          var comboboxField = _this.fields[field];

          if (comboboxField) {
            comboboxField.meta.ref = ref;
          }
        }
      };
    };

    _this.createPostalCodeInputMeta = function () {
      return {
        ref: null,
        props: _this.createPostalCodeInputProps(),
        tooltip: function tooltip() {
          return _this.createPostalCodeTooltip();
        },
        createRef: function createRef(ref) {
          var inputField = _this.fields[FiasExtraFields.postalcode];

          if (inputField) {
            inputField.meta.ref = ref;
          }
        }
      };
    };

    _this.createAddressComboBoxProps = function (field) {
      var getItems =
      /*#__PURE__*/
      function () {
        var _ref2 = _asyncToGenerator(
        /*#__PURE__*/
        _regeneratorRuntime.mark(function _callee2(searchText) {
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", _this.createItemsSource(searchText, field));

                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function getItems(_x) {
          return _ref2.apply(this, arguments);
        };
      }();

      var onValueChange = function onValueChange(value) {
        var address = _this.state.address;

        var newFields = _extends({}, address.fields, {}, value.fields); // get rid of undefineds


        var addressField;

        for (addressField in newFields) {
          if (!newFields[addressField]) {
            delete newFields[addressField];
          }
        }

        _this.handleAddressChange(FiasAddress.createFromAddress(address, {
          fields: newFields
        }), _this.validate);
      };

      var onInputValueChange = function onInputValueChange() {
        _this.resetAddressErrors();
      };

      var onUnexpectedInput = function onUnexpectedInput(query) {
        var _extends2;

        var address = _this.state.address;

        var newFields = _extends({}, address.fields, (_extends2 = {}, _extends2[field] = query ? new FiasAddressElement(field, query) : undefined, _extends2));

        return FiasAddress.createFromAddress(address, {
          fields: newFields
        });
      };

      var renderItem = function renderItem(address) {
        var element = address.fields[field];

        if (!element) {
          return '';
        }

        if (field === FiasFields.region && element.data) {
          var regionCode = element.data.code.substr(0, 2);
          return regionCode + " " + element.getText();
        }

        var diffAddress = new FiasAddress({
          fields: _this.state.address.getDiffFields(address, _this.props.fieldsSettings)
        });
        var hasParentFields = Boolean(diffAddress.getClosestParentFiasId(field));
        return hasParentFields ? diffAddress.getText() : element.getText(element.isTypeMatchField(field));
      };

      var renderValue = function renderValue(address) {
        var element = address.fields[field];
        return element && element.getText(element.isTypeMatchField(field));
      };

      var renderNotFound = function renderNotFound() {
        var address = _this.state.address;
        var messages = [_this.locale[field + "NotFound"] || _this.locale.addressNotFound];

        if (address.isAllowedToFill(field)) {
          if (address.hasOnlyIndirectParent(field)) {
            messages.push(_this.locale.addressFillParentOrSearch);
          }
        } else {
          messages = _this.locale[field + "FillBefore"] ? [_this.locale[field + "FillBefore"]] : messages;
        }

        return React.createElement("div", null, messages.map(function (message, i, m) {
          return React.createElement("div", {
            key: i
          }, message + (m[i + 1] ? '.' : ''));
        }));
      };

      var valueToString = function valueToString(address) {
        var element = address.fields[field];
        return element ? element.name : '';
      };

      var itemToValue = valueToString;
      return {
        getItems: getItems,
        onValueChange: onValueChange,
        onInputValueChange: onInputValueChange,
        onUnexpectedInput: onUnexpectedInput,
        renderItem: renderItem,
        renderValue: renderValue,
        itemToValue: itemToValue,
        valueToString: valueToString,
        renderNotFound: renderNotFound
      };
    };

    _this.createItemsSource =
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3(searchText, field) {
        var address, limit, options;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                address = _this.state.address;
                limit = _this.props.limit || FiasForm.defaultProps.limit;

                if (!address.isAllowedToFill(field)) {
                  _context3.next = 5;
                  break;
                }

                options = {
                  searchText: searchText,
                  field: field,
                  parentFiasId: address.getClosestParentFiasId(field),
                  fullAddress: address.isAllowedToSearchFullAddress(field),
                  directParent: !address.isAllowedToSearchThroughChildrenOfDirectParent(field, _this.props.fieldsSettings),
                  limit: limit + 1 // +1 to detect if there are more items

                };
                return _context3.abrupt("return", _this.props.api.search(options).then(function (result) {
                  var success = result.success,
                      data = result.data,
                      error = result.error;
                  return success && data ? Promise.resolve(data.map(function (item) {
                    return FiasAddress.createFromResponse(item);
                  })) : Promise.reject(error);
                }));

              case 5:
                return _context3.abrupt("return", Promise.resolve([]));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2, _x3) {
        return _ref3.apply(this, arguments);
      };
    }();

    _this.getFieldTooltipContent = function (field) {
      var address = _this.state.address;
      var validationLevel = _this.props.validationLevel;

      if (validationLevel !== FiasFormValidation.None && address.hasError(field)) {
        return address.getError(field);
      }

      return null;
    };

    _this.createAddressComboBoxTooltip = function (field) {
      return function () {
        var tooltipContent = _this.getFieldTooltipContent(field);

        var comboboxField = _this.fields[field];

        if (comboboxField && FiasForm.isComboboxMeta(comboboxField.meta)) {
          var combobox = comboboxField.meta.ref;
          var hasItems = combobox ? combobox.hasItems : false;
          return tooltipContent !== null && hasItems ? _this.locale.addressSelectItemFromList : tooltipContent;
        }

        return tooltipContent;
      };
    };

    _this.createPostalCodeTooltip = function () {
      var tooltipContent = _this.getFieldTooltipContent(FiasExtraFields.postalcode);

      var replacePostalCode = function replacePostalCode() {
        var address = _this.state.address;

        var additionalFields = _extends({}, address.additionalFields);

        delete additionalFields[FiasExtraFields.postalcode];

        _this.handleAddressChange(FiasAddress.createFromAddress(address, {
          additionalFields: additionalFields
        }));
      };

      return tooltipContent && React.createElement("div", null, React.createElement("span", null, tooltipContent), _this.state.address.isPostalCodeAltered && React.createElement("div", null, React.createElement(Button, {
        onClick: replacePostalCode,
        use: "link"
      }, _this.locale.postalcodeReplace)));
    };

    _this.verify = function () {
      var address = _this.state.address;
      var api = _this.props.api;
      return api.verify(address).then(function (result) {
        var success = result.success,
            data = result.data;

        if (success && data) {
          return FiasAddress.verify(address, data);
        }

        return FiasAddress.removeFiasData(address);
      });
    };

    _this.handleCountryChange = function (country) {
      _this.handleAddressChange(FiasAddress.createFromAddress(_this.state.address, {
        country: country
      }));
    };

    _this.handleForeignAddressChange = function (value) {
      _this.handleAddressChange(FiasAddress.createFromAddress(_this.state.address, {
        foreignAddress: value
      }));
    };

    _this.handleAddressChange = function (address, callback) {
      _this.setState({
        address: FiasAddress.createFromAddress(address, {
          fields: FiasAddress.filterVisibleFields(address.fields, _this.props.fieldsSettings)
        })
      }, callback);
    };

    _this.handleSearchChange = function (address) {
      _this.handleAddressChange(address);
    };

    _this.resetAddressErrors = function () {
      var address = _this.state.address;

      if (address.hasErrors) {
        _this.setState({
          address: FiasAddress.createFromAddress(address, {
            errors: {}
          })
        });
      }
    };

    _this.fields = FiasAddress.ALL_FIELDS.reduce(function (fields, field) {
      var _extends3, _extends4;

      switch (field) {
        case FiasFields.region:
        case FiasFields.district:
        case FiasFields.city:
        case FiasFields.intracityarea:
        case FiasFields.settlement:
        case FiasFields.planningstructure:
        case FiasFields.street:
        case FiasFields.stead:
        case FiasFields.house:
        case FiasFields.room:
          return _extends({}, fields, (_extends3 = {}, _extends3[field] = {
            meta: _this.createAddressComboboxMeta(field),
            render: function render() {
              return _this.renderAddressComboBox(field);
            }
          }, _extends3));

        case FiasExtraFields.postalcode:
          return _extends({}, fields, (_extends4 = {}, _extends4[field] = {
            meta: _this.createPostalCodeInputMeta(),
            render: function render() {
              return _this.renderPostalCodeInput();
            }
          }, _extends4));

        default:
          return fields;
      }
    }, {});
    return _this;
  }

  var _proto = FiasForm.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.validate();
  };

  _proto.render = function render() {
    var address = this.state.address;
    var _this$props = this.props,
        api = _this$props.api,
        limit = _this$props.limit,
        countrySelector = _this$props.countrySelector;
    return React.createElement("div", null, React.createElement(Gapped, {
      vertical: true
    }, countrySelector && React.createElement(FiasForm.Field, {
      label: this.locale.countryLabel
    }, React.createElement(FiasCountrySelector, {
      api: api,
      country: address.country,
      onValueChange: this.handleCountryChange,
      limit: limit
    })), this.props.search && React.createElement(FiasForm.Field, null, React.createElement(FiasSearch, {
      api: api,
      address: address,
      onValueChange: this.handleSearchChange,
      limit: limit,
      placeholder: this.locale.searchPlaceholder
    })), this.isForeignForm ? React.createElement(Gapped, {
      vertical: true
    }, React.createElement(FiasForm.Field, {
      label: this.locale.foreignAddressLabel
    }, React.createElement(Textarea, {
      value: address.foreignAddress,
      onValueChange: this.handleForeignAddressChange,
      placeholder: this.locale.foreignAddressPlaceholder,
      width: "100%",
      resize: "none"
    })), this.renderFields([FiasExtraFields.postalcode])) : this.renderFields(FiasAddress.ALL_FIELDS)));
  };

  _proto.createPostalCodeInputProps = function createPostalCodeInputProps() {
    var _this2 = this;

    return {
      onValueChange: function onValueChange(value) {
        var _extends5;

        var address = _this2.state.address;

        var newAdditionalFields = _extends({}, address.additionalFields, (_extends5 = {}, _extends5[FiasExtraFields.postalcode] = value, _extends5));

        _this2.handleAddressChange(FiasAddress.createFromAddress(address, {
          additionalFields: newAdditionalFields
        }));
      }
    };
  };

  _proto.validate = function validate() {
    var _this3 = this;

    var verifyPromise = this.lastVerifyPromise = this.verify();
    verifyPromise.then(function (verifiedAddress) {
      if (verifyPromise === _this3.lastVerifyPromise) {
        _this3.setState({
          address: FiasAddress.validate(verifiedAddress, _this3.locale)
        });
      }
    });
  };

  _createClass(FiasForm, [{
    key: "isForeignForm",
    get: function get() {
      var address = this.state.address;
      var countrySelector = this.props.countrySelector;
      return address.isForeign || Boolean(countrySelector) && !address.country;
    }
  }]);

  return FiasForm;
}(React.Component), _class2.__KONTUR_REACT_UI__ = 'FiasForm', _class2.defaultProps = {
  validationLevel: 'Error',
  limit: 5,
  fieldsSettings: {},
  countrySelector: false
}, _class2.Field = function (_ref4) {
  var label = _ref4.label,
      children = _ref4.children;
  return React.createElement("div", {
    className: jsStyles.row()
  }, label && React.createElement("div", {
    className: jsStyles.label()
  }, label), React.createElement("div", {
    className: jsStyles.field()
  }, children));
}, _class2.isComboboxMeta = function (meta) {
  var props = meta.props;
  return Object.prototype.hasOwnProperty.call(props, 'onUnexpectedInput') && Object.prototype.hasOwnProperty.call(props, 'getItems');
}, _class2.isInputMeta = function (meta) {
  var props = meta.props;
  return !FiasForm.isComboboxMeta(meta) && Object.prototype.hasOwnProperty.call(props, 'onValueChange');
}, _temp)) || _class);