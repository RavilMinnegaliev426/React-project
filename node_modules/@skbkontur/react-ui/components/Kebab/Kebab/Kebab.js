import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import { isKeyArrowVertical, isKeyEnter, isKeySpace, someKeys } from "../../../lib/events/keyboard/identifiers";
import { Icon as Icon20 } from "../../../internal/icons/20px";
import * as LayoutEvents from "../../../lib/LayoutEvents";
import { tabListener } from "../../../lib/events/tabListener";
import { PopupMenu } from "../../../internal/PopupMenu";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { MenuKebabIcon } from "../../../internal/icons/16px";
import { jsStyles } from "../Kebab.styles";
export var Kebab =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Kebab, _React$Component);

  function Kebab() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      opened: false,
      focusedByTab: false,
      anchor: null
    };
    _this.theme = void 0;
    _this.listener = {
      remove: function remove() {
        return undefined;
      }
    };

    _this.renderCaption = function (captionProps) {
      var _cn;

      var disabled = _this.props.disabled;

      var handleCaptionKeyDown = function handleCaptionKeyDown(event) {
        if (!disabled) {
          _this.handleCaptionKeyDown(event, captionProps.openMenu);
        }
      };

      var handleCaptionClick = function handleCaptionClick() {
        if (!disabled) {
          captionProps.toggleMenu();
        }
      };

      return React.createElement("span", {
        tabIndex: disabled ? -1 : 0,
        onClick: handleCaptionClick,
        onKeyDown: handleCaptionKeyDown,
        onFocus: _this.handleFocus,
        onBlur: _this.handleBlur,
        className: cn((_cn = {}, _cn[jsStyles.kebab()] = true, _cn[jsStyles.opened()] = captionProps.opened, _cn[jsStyles.disabled()] = disabled, _cn[jsStyles.focused(_this.theme)] = _this.state.focusedByTab, _cn))
      }, _this.renderIcon());
    };

    _this.handleCaptionKeyDown = function (e, openMenu) {
      if (someKeys(isKeyEnter, isKeySpace, isKeyArrowVertical)(e)) {
        e.preventDefault();
        openMenu(true);
      }
    };

    _this.handleChangeMenuState = function (isOpened, restoreFocus) {
      _this.setState({
        opened: isOpened,
        focusedByTab: !isOpened && restoreFocus
      }, function () {
        if (_this.props.disabled) {
          return;
        }

        if (_this.state.opened) {
          _this.props.onOpen();
        } else {
          _this.props.onClose();
        }
      });
    };

    _this.handleFocus = function () {
      if (!_this.props.disabled) {
        // focus event fires before keyDown eventlistener
        // so we should check tabPressed in async way
        process.nextTick(function () {
          if (tabListener.isTabPressed) {
            _this.setState({
              focusedByTab: true
            });
          }
        });
      }
    };

    _this.handleBlur = function () {
      _this.setState({
        focusedByTab: false
      });
    };

    return _this;
  }

  var _proto = Kebab.prototype;

  _proto.componentDidMount = function componentDidMount() {
    /** addListener'у нужен колбэк в аргумент */
    this.listener = LayoutEvents.addListener(function () {
      return undefined;
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.listener.remove();
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  };

  _proto.renderMain = function renderMain() {
    var _this$props = this.props,
        disabled = _this$props.disabled,
        positions = _this$props.positions;
    return React.createElement(PopupMenu, {
      popupMargin: 5,
      popupPinOffset: 15,
      popupHasPin: true,
      positions: positions,
      onChangeMenuState: this.handleChangeMenuState,
      caption: this.renderCaption,
      disableAnimations: this.props.disableAnimations
    }, !disabled && this.props.children);
  };

  _proto.renderIcon = function renderIcon() {
    switch (this.props.size) {
      case 'small':
        return React.createElement("div", {
          className: jsStyles.iconsmall()
        }, React.createElement(MenuKebabIcon, {
          size: "14px",
          color: "#757575"
        }));

      case 'medium':
        return React.createElement("div", {
          className: jsStyles.iconmedium()
        }, React.createElement(MenuKebabIcon, {
          size: "18px",
          color: "#757575"
        }));

      case 'large':
        return React.createElement("div", {
          className: jsStyles.iconlarge()
        }, React.createElement(Icon20, {
          name: "kebab",
          color: "#757575"
        }));

      default:
        throw new Error("Unexpected size '" + this.props.size + "'");
    }
  };

  return Kebab;
}(React.Component);
Kebab.__KONTUR_REACT_UI__ = 'Kebab';
Kebab.propTypes = {};
Kebab.defaultProps = {
  onOpen: function onOpen() {
    return undefined;
  },
  onClose: function onClose() {
    return undefined;
  },
  positions: ['bottom left', 'bottom right', 'top left', 'top right'],
  size: 'small',
  disableAnimations: Boolean(process.env.enableReactTesting)
};
Kebab.propTypes = {
  children: PropTypes.node,
  disabled: PropTypes.bool,
  menuMaxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
                                                                             * Размер кебаба small 14px | large 20px
                                                                             */
  size: PropTypes.string,

  /**
                           * Коллбек, вызывающийся перед закрытием кебаба
                           */
  onClose: PropTypes.func,

  /**
                            * Коллбек, вызывающийся перед открытием кебаба
                            */
  onOpen: PropTypes.func
};