import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';
import * as LayoutEvents from "../../../lib/LayoutEvents";
import { getScrollWidth } from "../../../lib/dom/getScrollWidth";
import { isChrome, isOpera, isSafari } from "../../../lib/utils";
import { jsStyles } from "../ScrollContainer.styles";
var PADDING_RIGHT = 30;
var MIN_SCROLL_SIZE = 20;
var SCROLL_HIDDEN = isChrome || isOpera || isSafari;
export var ScrollContainer =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ScrollContainer, _React$Component);

  function ScrollContainer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      scrollActive: false,
      scrollSize: 0,
      scrollPos: 0,
      // Mouse is moving where big scrollbar can be located.
      hover: false,
      // True when scroll is following mouse (mouse down on scroll).
      scrolling: false,
      scrollState: 'top'
    };
    _this.inner = void 0;
    _this.scroll = void 0;

    _this.refInner = function (element) {
      if (!_this.inner && element && _this.props.preventWindowScroll) {
        element.addEventListener('wheel', _this.handleInnerScrollWheel, {
          passive: false
        });
      }

      if (_this.inner && !element) {
        _this.inner.removeEventListener('wheel', _this.handleInnerScrollWheel);
      }

      _this.inner = element;
    };

    _this.refScroll = function (element) {
      if (!_this.scroll && element) {
        element.addEventListener('wheel', _this.handleScrollWheel, {
          passive: false
        });
      }

      if (_this.scroll && !element) {
        _this.scroll.removeEventListener('wheel', _this.handleScrollWheel);
      }

      _this.scroll = element;
    };

    _this.handleNativeScroll = function (event) {
      _this.reflow();

      if (_this.props.preventWindowScroll) {
        event.preventDefault();
        return;
      }

      LayoutEvents.emit();
    };

    _this.reflow = function () {
      if (!_this.inner) {
        return;
      }

      var containerHeight = _this.inner.offsetHeight;
      var contentHeight = _this.inner.scrollHeight;
      var scrollTop = _this.inner.scrollTop;
      var scrollActive = containerHeight < contentHeight;

      if (!scrollActive && !_this.state.scrollActive) {
        return;
      }

      if (scrollActive) {
        var scrollSize = containerHeight / contentHeight * containerHeight;

        if (scrollSize < MIN_SCROLL_SIZE) {
          scrollSize = MIN_SCROLL_SIZE;
        }

        var scrollPos = scrollTop / (contentHeight - containerHeight) * (containerHeight - scrollSize);

        if (_this.state.scrollSize !== scrollSize || _this.state.scrollPos !== scrollPos) {
          var _scrollState = _this.state.scrollState;

          var updatedScrollState = _this.getImmediateScrollState();

          var scrollParamsToUpdate = {
            scrollActive: true,
            scrollSize: scrollSize,
            scrollPos: scrollPos,
            scrollState: _scrollState
          };

          if (updatedScrollState !== _this.state.scrollState) {
            scrollParamsToUpdate.scrollState = updatedScrollState;

            if (_this.props.onScrollStateChange) {
              _this.props.onScrollStateChange(updatedScrollState);
            }
          }

          _this.setState(scrollParamsToUpdate);
        }
      } else {
        _this.setState({
          scrollActive: false,
          scrollSize: 0,
          scrollPos: 0
        });
      }
    };

    _this.handleScrollMouseDown = function (event) {
      if (!_this.inner) {
        return;
      }

      var target = window.document;
      var initialY = event.clientY;
      var initialScrollTop = _this.inner.scrollTop;

      var mouseMove = function mouseMove(mouseMoveEvent) {
        if (!_this.inner) {
          return;
        }

        var ratio = (_this.inner.scrollHeight - _this.inner.offsetHeight) / (_this.inner.offsetHeight - _this.state.scrollSize);
        var deltaY = (mouseMoveEvent.clientY - initialY) * ratio;
        _this.inner.scrollTop = initialScrollTop + deltaY;

        if (mouseMoveEvent.preventDefault) {
          mouseMoveEvent.preventDefault();
        }

        if (Object.prototype.hasOwnProperty.call(mouseMoveEvent, 'returnValue')) {
          mouseMoveEvent.returnValue = false;
        }
      };

      var mouseUp = function mouseUp() {
        target.removeEventListener('mousemove', mouseMove);
        target.removeEventListener('mouseup', mouseUp);

        _this.setState({
          scrolling: false
        });
      };

      target.addEventListener('mousemove', mouseMove);
      target.addEventListener('mouseup', mouseUp);

      _this.setState({
        scrolling: true
      });

      event.preventDefault();
    };

    _this.handleScrollWheel = function (event) {
      if (!_this.inner || !(event instanceof WheelEvent)) {
        return;
      }

      if (event.deltaY > 0 && _this.inner.scrollHeight <= _this.inner.scrollTop + _this.inner.offsetHeight) {
        return;
      }

      if (event.deltaY < 0 && _this.inner.scrollTop <= 0) {
        return;
      }

      _this.inner.scrollTop += event.deltaY;
      event.preventDefault();
    };

    _this.handleInnerScrollWheel = function (event) {
      if (!_this.inner || !(event instanceof WheelEvent)) {
        return;
      }

      if (event.deltaY > 0 && _this.inner.scrollHeight <= _this.inner.scrollTop + _this.inner.offsetHeight) {
        event.preventDefault();
        return false;
      }

      if (event.deltaY < 0 && _this.inner.scrollTop <= 0) {
        event.preventDefault();
        return false;
      }
    };

    _this.handleMouseMove = function (event) {
      var right = event.currentTarget.getBoundingClientRect().right - event.pageX;

      _this.setHover(right <= 12);
    };

    _this.handleMouseLeave = function () {
      _this.setHover(false);
    };

    return _this;
  }

  var _proto = ScrollContainer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.reflow();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.inner) {
      if (prevProps.preventWindowScroll && !this.props.preventWindowScroll) {
        this.inner.removeEventListener('wheel', this.handleInnerScrollWheel);
      }

      if (!prevProps.preventWindowScroll && this.props.preventWindowScroll) {
        this.inner.addEventListener('wheel', this.handleInnerScrollWheel, {
          passive: false
        });
      }
    }

    this.reflow();
  };

  _proto.render = function render() {
    var state = this.state;
    var props = this.props;
    var scroll = null;

    if (state.scrollActive) {
      var _cn;

      var scrollClass = cn((_cn = {}, _cn[jsStyles.scroll()] = true, _cn[jsStyles.scrollInvert()] = Boolean(props.invert), _cn[jsStyles.scrollHover()] = state.hover || state.scrolling, _cn));
      var scrollStyle = {
        top: state.scrollPos,
        height: state.scrollSize
      };
      scroll = React.createElement("div", {
        ref: this.refScroll,
        className: scrollClass,
        style: scrollStyle,
        onMouseDown: this.handleScrollMouseDown
      });
    }

    var innerStyle = {
      marginRight: this.getMarginRight(),
      maxHeight: props.maxHeight,
      paddingRight: PADDING_RIGHT,
      scrollBehavior: props.scrollBehaviour
    };
    return React.createElement("div", {
      className: jsStyles.root(),
      onMouseMove: this.handleMouseMove,
      onMouseLeave: this.handleMouseLeave
    }, scroll, React.createElement("div", {
      "data-tid": "ScrollContainer__inner",
      className: jsStyles.inner(),
      style: innerStyle,
      ref: this.refInner,
      onScroll: this.handleNativeScroll
    }, props.children));
  }
  /**
   * @public
   */
  ;

  _proto.scrollTo = function scrollTo(element) {
    if (!element || !this.inner) {
      return;
    }

    var maxScroll = element.offsetTop;

    if (this.inner.scrollTop > maxScroll) {
      this.inner.scrollTop = maxScroll;
      return;
    }

    var minScroll = element.offsetTop + element.scrollHeight - this.inner.offsetHeight;

    if (this.inner.scrollTop < minScroll) {
      this.inner.scrollTop = minScroll;
    }
  }
  /**
   * @public
   */
  ;

  _proto.scrollToTop = function scrollToTop() {
    if (!this.inner) {
      return;
    }

    this.inner.scrollTop = 0;
  }
  /**
   * @public
   */
  ;

  _proto.scrollToBottom = function scrollToBottom() {
    if (!this.inner) {
      return;
    }

    this.inner.scrollTop = this.inner.scrollHeight - this.inner.offsetHeight;
  };

  _proto.setHover = function setHover(hover) {
    if (this.state.hover !== hover) {
      this.setState({
        hover: hover
      });
    }
  };

  _proto.getImmediateScrollState = function getImmediateScrollState() {
    if (!this.inner || this.inner.scrollTop === 0) {
      return 'top';
    } else if (this.inner.scrollTop === this.inner.scrollHeight - this.inner.offsetHeight) {
      return 'bottom';
    } else {
      return 'scroll';
    }
  };

  _proto.getMarginRight = function getMarginRight() {
    return -1 * (PADDING_RIGHT + (SCROLL_HIDDEN ? 0 : getScrollWidth()));
  };

  return ScrollContainer;
}(React.Component);
ScrollContainer.__KONTUR_REACT_UI__ = 'ScrollContainer';
ScrollContainer.propTypes = {
  invert: PropTypes.bool,
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  scrollBehaviour: PropTypes.oneOf(['auto', 'smooth']),
  preventWindowScroll: PropTypes.bool,
  onScrollStateChange: PropTypes.func
};
ScrollContainer.defaultProps = {
  scrollBehaviour: 'auto'
};