import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import invariant from 'invariant';
import React from 'react';
import raf from 'raf';
import cn from 'classnames';
import { isIE11, isEdge } from "../../../lib/utils";
import { isKeyBackspace, isKeyDelete, someKeys } from "../../../lib/events/keyboard/identifiers";
import { polyfillPlaceholder } from "../../../lib/polyfillPlaceholder";
import { MaskedInput } from "../../../internal/MaskedInput";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { jsStyles } from "../Input.styles";
/**
                                            * Интерфес пропсов наследуется от `React.InputHTMLAttributes<HTMLInputElement>`.
                                            *  Все пропсы кроме перечисленных, `className` и `style` передаются в `<input>`
                                            */

export var Input =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Input, _React$Component);

  function Input() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      polyfillPlaceholder: false,
      blinking: false,
      focused: false
    };
    _this.selectAllId = null;
    _this.theme = void 0;
    _this.blinkTimeout = 0;
    _this.input = null;

    _this.selectAll = function () {
      if (_this.input) {
        _this.setSelectionRange(0, _this.input.value.length);
      }
    };

    _this.delaySelectAll = function () {
      return _this.selectAllId = raf(_this.selectAll);
    };

    _this.cancelDelayedSelectAll = function () {
      if (_this.selectAllId) {
        raf.cancel(_this.selectAllId);
        _this.selectAllId = null;
      }
    };

    _this.cancelBlink = function (callback) {
      if (_this.blinkTimeout) {
        clearTimeout(_this.blinkTimeout);
        _this.blinkTimeout = 0;

        if (_this.state.blinking) {
          _this.setState({
            blinking: false
          }, callback);

          return;
        }
      }

      if (callback) {
        callback();
      }
    };

    _this.refInput = function (element) {
      if (element instanceof MaskedInput) {
        _this.input = element.input;
      } else {
        _this.input = element;
      }
    };

    _this.handleChange = function (event) {
      if (polyfillPlaceholder) {
        var fieldIsEmpty = event.target.value === '';

        if (_this.state.polyfillPlaceholder !== fieldIsEmpty) {
          _this.setState({
            polyfillPlaceholder: fieldIsEmpty
          });
        }
      }

      if (_this.props.onValueChange) {
        _this.props.onValueChange(event.target.value);
      }

      if (_this.props.onChange) {
        _this.props.onChange(event);
      }
    };

    _this.handleFocus = function (event) {
      _this.setState({
        focused: true
      });

      if (_this.props.selectAllOnFocus) {
        // https://github.com/facebook/react/issues/7769
        _this.input ? _this.selectAll() : _this.delaySelectAll();
      }

      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };

    _this.handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      var isDeleteKey = someKeys(isKeyBackspace, isKeyDelete)(e);

      if (!e.currentTarget.value && isDeleteKey && !e.repeat) {
        _this.handleUnexpectedInput();
      }
    };

    _this.handleKeyPress = function (event) {
      if (_this.props.onKeyPress) {
        _this.props.onKeyPress(event);
      }

      if (_this.props.maxLength === event.currentTarget.value.length) {
        _this.handleUnexpectedInput(event.currentTarget.value);
      }
    };

    _this.handleMaskedValueChange = function (value) {
      if (_this.props.onValueChange) {
        _this.props.onValueChange(value);
      }
    };

    _this.handleUnexpectedInput = function (value) {
      if (value === void 0) {
        value = _this.props.value || '';
      }

      if (_this.props.onUnexpectedInput) {
        _this.props.onUnexpectedInput(value);
      } else {
        _this.blink();
      }
    };

    _this.handleBlur = function (event) {
      _this.setState({
        focused: false
      });

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    };

    _this.renderPrefix = function () {
      var prefix = _this.props.prefix;

      if (!prefix) {
        return null;
      }

      return React.createElement("span", {
        className: jsStyles.prefix(_this.theme)
      }, prefix);
    };

    _this.renderSuffix = function () {
      var suffix = _this.props.suffix;

      if (!suffix) {
        return null;
      }

      return React.createElement("span", {
        className: jsStyles.suffix(_this.theme)
      }, suffix);
    };

    return _this;
  }

  var _proto = Input.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (polyfillPlaceholder) {
      this.setState({
        polyfillPlaceholder: true
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.blinkTimeout) {
      clearTimeout(this.blinkTimeout);
    }

    this.cancelDelayedSelectAll();
  };

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    if (polyfillPlaceholder && !nextProps.value) {
      this.setState({
        polyfillPlaceholder: true
      });
    }
  }
  /**
   * @public
   */
  ;

  _proto.focus = function focus() {
    invariant(this.input, 'Cannot call "focus" because Input is not mounted');
    this.input.focus();
  }
  /**
   * @public
   */
  ;

  _proto.blur = function blur() {
    invariant(this.input, 'Cannot call "blur" because Input is not mounted');
    this.input.blur();
  }
  /**
   * @public
   */
  ;

  _proto.blink = function blink() {
    var _this2 = this;

    if (this.blinkTimeout) {
      this.cancelBlink(function () {
        // trigger reflow to restart animation
        // @see https://css-tricks.com/restart-css-animation/#article-header-id-0
        void (_this2.input && _this2.input.offsetWidth);

        _this2.blink();
      });
      return;
    }

    this.setState({
      blinking: true
    }, function () {
      _this2.blinkTimeout = window.setTimeout(_this2.cancelBlink, 150);
    });
  }
  /**
   * @public
   */
  ;

  _proto.setSelectionRange = function setSelectionRange(start, end) {
    if (!this.input) {
      throw new Error('Cannot call "setSelectionRange" on unmounted Input');
    }

    if (document.activeElement !== this.input) {
      this.focus();
    }

    this.input.setSelectionRange(start, end);
  };

  _proto.render = function render() {
    var _this3 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this3.theme = theme;
      return _this3.renderMain();
    });
  }
  /**
   * @public
   */
  ;

  _proto.renderMain = function renderMain() {
    var _cn;

    var _this$props = this.props,
        onMouseEnter = _this$props.onMouseEnter,
        onMouseLeave = _this$props.onMouseLeave,
        onMouseOver = _this$props.onMouseOver,
        onKeyDown = _this$props.onKeyDown,
        onKeyPress = _this$props.onKeyPress,
        onValueChange = _this$props.onValueChange,
        width = _this$props.width,
        error = _this$props.error,
        warning = _this$props.warning,
        leftIcon = _this$props.leftIcon,
        rightIcon = _this$props.rightIcon,
        borderless = _this$props.borderless,
        value = _this$props.value,
        align = _this$props.align,
        type = _this$props.type,
        mask = _this$props.mask,
        maskChar = _this$props.maskChar,
        alwaysShowMask = _this$props.alwaysShowMask,
        style = _this$props.style,
        className = _this$props.className,
        size = _this$props.size,
        placeholder = _this$props.placeholder,
        selectAllOnFocus = _this$props.selectAllOnFocus,
        disabled = _this$props.disabled,
        onUnexpectedInput = _this$props.onUnexpectedInput,
        prefix = _this$props.prefix,
        suffix = _this$props.suffix,
        formatChars = _this$props.formatChars,
        rest = _objectWithoutPropertiesLoose(_this$props, ["onMouseEnter", "onMouseLeave", "onMouseOver", "onKeyDown", "onKeyPress", "onValueChange", "width", "error", "warning", "leftIcon", "rightIcon", "borderless", "value", "align", "type", "mask", "maskChar", "alwaysShowMask", "style", "className", "size", "placeholder", "selectAllOnFocus", "disabled", "onUnexpectedInput", "prefix", "suffix", "formatChars"]);

    var _this$state = this.state,
        blinking = _this$state.blinking,
        focused = _this$state.focused;
    var labelProps = {
      className: cn(jsStyles.root(this.theme), this.getSizeClassName(), (_cn = {}, _cn[jsStyles.borderless()] = !!borderless, _cn[jsStyles.focus(this.theme)] = focused, _cn[jsStyles.blink(this.theme)] = !!blinking, _cn[jsStyles.warning(this.theme)] = !!warning, _cn[jsStyles.error(this.theme)] = !!error, _cn[jsStyles.disabled(this.theme)] = !!disabled, _cn[jsStyles.focusFallback(this.theme)] = focused && (isIE11 || isEdge), _cn[jsStyles.warningFallback(this.theme)] = !!warning && (isIE11 || isEdge), _cn[jsStyles.errorFallback(this.theme)] = !!error && (isIE11 || isEdge), _cn)),
      style: {
        width: width
      },
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onMouseOver: onMouseOver
    };

    var inputProps = _extends({}, rest, {
      className: jsStyles.input(this.theme),
      value: value,
      onChange: this.handleChange,
      onFocus: this.handleFocus,
      onKeyDown: this.handleKeyDown,
      onKeyPress: this.handleKeyPress,
      onBlur: this.handleBlur,
      style: {
        textAlign: align
      },
      ref: this.refInput,
      type: 'text',
      placeholder: !this.isMaskVisible && !polyfillPlaceholder ? placeholder : undefined,
      disabled: disabled
    });

    if (type === 'password') {
      inputProps.type = type;
    }

    var input = mask ? this.renderMaskedInput(inputProps, mask) : React.createElement('input', inputProps);
    return React.createElement("label", labelProps, React.createElement("span", {
      className: jsStyles.sideContainer()
    }, this.renderLeftIcon(), this.renderPrefix()), React.createElement("span", {
      className: jsStyles.wrapper()
    }, input, this.renderPlaceholder()), React.createElement("span", {
      className: cn(jsStyles.sideContainer(), jsStyles.rightContainer())
    }, this.renderSuffix(), this.renderRightIcon()));
  };

  _proto.renderMaskedInput = function renderMaskedInput(inputProps, mask) {
    return React.createElement(MaskedInput, _extends({}, inputProps, {
      mask: mask,
      maskChar: this.props.maskChar === undefined ? '_' : this.props.maskChar,
      alwaysShowMask: this.props.alwaysShowMask,
      formatChars: this.props.formatChars,
      onChange: this.props.onChange,
      onValueChange: this.handleMaskedValueChange,
      onUnexpectedInput: this.handleUnexpectedInput
    }));
  };

  _proto.renderLeftIcon = function renderLeftIcon() {
    return this.renderIcon(this.props.leftIcon, jsStyles.leftIcon());
  };

  _proto.renderRightIcon = function renderRightIcon() {
    return this.renderIcon(this.props.rightIcon, jsStyles.rightIcon());
  };

  _proto.renderIcon = function renderIcon(icon, className) {
    if (!icon) {
      return null;
    }

    if (icon instanceof Function) {
      return React.createElement("span", {
        className: className
      }, icon());
    }

    return React.createElement("span", {
      className: cn(className, jsStyles.useDefaultColor(this.theme), jsStyles.useDefaultColor(this.theme))
    }, icon);
  };

  _proto.renderPlaceholder = function renderPlaceholder() {
    var placeholder = null;

    if (this.state.polyfillPlaceholder && this.props.placeholder && !this.isMaskVisible && !this.props.value) {
      placeholder = React.createElement("div", {
        className: cn(jsStyles.placeholder(this.theme), jsStyles.placeholder(this.theme)),
        style: {
          textAlign: this.props.align || 'inherit'
        }
      }, this.props.placeholder);
    }

    return placeholder;
  };

  _proto.getSizeClassName = function getSizeClassName() {
    var _ref, _ref2, _ref3;

    switch (this.props.size) {
      case 'large':
        return _ref = {}, _ref[jsStyles.sizeLarge(this.theme)] = true, _ref[jsStyles.sizeLargeFallback(this.theme)] = isIE11 || isEdge, _ref;

      case 'medium':
        return _ref2 = {}, _ref2[jsStyles.sizeMedium(this.theme)] = true, _ref2[jsStyles.sizeMediumFallback(this.theme)] = isIE11 || isEdge, _ref2;

      case 'small':
      default:
        return _ref3 = {}, _ref3[jsStyles.sizeSmall(this.theme)] = true, _ref3[jsStyles.sizeSmallFallback(this.theme)] = isIE11 || isEdge, _ref3;
    }
  };

  _createClass(Input, [{
    key: "isMaskVisible",
    get: function get() {
      var _this$props2 = this.props,
          mask = _this$props2.mask,
          alwaysShowMask = _this$props2.alwaysShowMask;
      var focused = this.state.focused;
      return Boolean(mask && (focused || alwaysShowMask));
    }
  }]);

  return Input;
}(React.Component);
Input.__KONTUR_REACT_UI__ = 'Input';
Input.defaultProps = {
  size: 'small'
};