import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import invariant from 'invariant';
import cn from 'classnames';
import { getRandomID } from "../../../lib/utils";
import { Radio } from "../../Radio";
import { createPropsGetter } from "../../../lib/createPropsGetter";
import { FocusTrap } from "../../../internal/FocusTrap";
import { jsStyles } from "../RadioGroup.styles";
import { Prevent } from "../Prevent";
export var RadioGroup =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(RadioGroup, _React$Component);

  function RadioGroup(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.node = void 0;
    _this.name = getRandomID();
    _this.getProps = createPropsGetter(RadioGroup.defaultProps);

    _this.getValue = function () {
      return _this.isControlled() ? _this.props.value : _this.state.activeItem;
    };

    _this.getName = function () {
      return _this.props.name || _this.name;
    };

    _this.isControlled = function () {
      return _this.props.value != null;
    };

    _this.handleSelect = function (value) {
      if (!_this.isControlled()) {
        _this.setState({
          activeItem: value
        });
      }

      if (_this.props.onValueChange) {
        _this.props.onValueChange(value);
      }
    };

    _this.renderRadio = function (itemValue, data, index) {
      var _cn;

      var itemProps = {
        key: typeof itemValue === 'string' || typeof itemValue === 'number' ? itemValue : index,
        className: cn((_cn = {}, _cn[jsStyles.item()] = true, _cn[jsStyles.itemFirst()] = index === 0, _cn[jsStyles.itemInline()] = !!_this.props.inline, _cn))
      };
      return React.createElement("span", itemProps, React.createElement(Radio, {
        value: itemValue
      }, _this.getProps().renderItem(itemValue, data)));
    };

    _this.ref = function (element) {
      _this.node = element;
    };

    _this.state = {
      activeItem: _this.props.defaultValue
    };
    return _this;
  }

  var _proto = RadioGroup.prototype;

  _proto.getChildContext = function getChildContext() {
    return {
      activeItem: this.getValue(),
      onSelect: this.handleSelect,
      name: this.getName(),
      disabled: this.props.disabled,
      error: this.props.error,
      warning: this.props.warning
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        width = _this$props.width,
        onMouseLeave = _this$props.onMouseLeave,
        onMouseOver = _this$props.onMouseOver,
        onMouseEnter = _this$props.onMouseEnter,
        onBlur = _this$props.onBlur;
    var style = {
      width: width != null ? width : 'auto'
    };
    var handlers = {
      onMouseOver: onMouseOver,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave
    };
    return React.createElement(FocusTrap, {
      onBlur: onBlur
    }, React.createElement("span", _extends({
      ref: this.ref,
      style: style,
      className: jsStyles.root()
    }, handlers), this.renderChildren()));
  }
  /**
   * @public
   */
  ;

  _proto.focus = function focus() {
    var node = this.node;

    if (!node) {
      return;
    }

    var radio = node.querySelector('input[type="radio"]:checked'); // If no checked radios, try get first radio

    if (!radio || radio.disabled) {
      radio = node.querySelector('input[type="radio"]:not([disabled])');
    }

    if (radio) {
      radio.focus();
    }
  };

  _proto.renderChildren = function renderChildren() {
    var _this$props2 = this.props,
        items = _this$props2.items,
        children = _this$props2.children;
    invariant(!items && children || items && !children, 'Either items or children must be passed, not both');
    return items ? mapItems(this.renderRadio, items) : children;
  };

  return RadioGroup;
}(React.Component);
RadioGroup.__KONTUR_REACT_UI__ = 'RadioGroup';
RadioGroup.childContextTypes = {
  error: PropTypes.bool,
  name: PropTypes.string,
  warning: PropTypes.bool,
  disabled: PropTypes.bool,
  activeItem: PropTypes.any,
  onSelect: PropTypes.func
};
RadioGroup.propTypes = {
  /**
   * Может быть использовано, если не передан параметр `items`
   *
   * `children` может содержать любую разметку с компонентами Radio.
   * Каждому компоненту Radio нужно указать параметр `value`, такого же типа
   * как и параметр `value` самой радиогруппы.
   *
   * Значения активного элемента сравниваются по строгому равенству `===`
   */
  children: PropTypes.node,

  /**
   * Значение по умолчанию. Должно быть одним из значений дочерних радиокнопок
   * или значей из параметра `items`
   */
  defaultValue: PropTypes.any,

  /**
   * Дизейблит все радиокнопки
   */
  disabled: PropTypes.bool,

  /**
   * Переводит все радиокнопки в состоянии ошибки
   */
  error: PropTypes.bool,

  /**
   * Выравнивает элементы в строку. Не работает с `children`
   */
  inline: PropTypes.bool,

  /**
   * Может быть использовано, если не передан параметр `children`
   *
   * Массив параметров радиокнопок. Может быть типа `Array<Value>` или
   * `Array<[Value, Data]>`, где тип `Value` — значение радиокнопки, а `Data`
   * — значение которое будет использовано вторым параметром в `renderItem`.
   * Если тип `items: Array<Value>`, то он будет приведен к типу
   * `Array<[Value, Value]>`
   */
  items: PropTypes.any,

  /**
   * Аттрибут name для вложенных радиокнопок. Если не указан, то сгенерируется
   * случайное имя по алгоритму
   * [uuid v1](https://github.com/kelektiv/node-uuid#version-1)
   */
  name: PropTypes.string,

  /**
   * Метод отрисовки контента радиокнопки. Не работает с `children`.
   *
   * Принимает два аргумента: `(value: Value, data: Data) => React.Node`
   */
  renderItem: PropTypes.func,

  /**
   * Значение радиогруппы. Должно быть одним из значений радиокнопок.
   * Если не указано, то компонент будет работать, как неконтроллируемый
   */
  value: PropTypes.any,

  /**
   * Переводит все радиокнопки в состоянии предупреждения
   */
  warning: PropTypes.bool,

  /**
   * Ширина радиогруппы. Не работает с `children`
   */
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Обработчик события при переключении радиокнопок.
   * Имеет тип
   * `(value: Value) => any`
   */
  onValueChange: PropTypes.func,
  onBlur: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onMouseOver: PropTypes.func
};
RadioGroup.defaultProps = {
  renderItem: renderItem
};
RadioGroup.Prevent = Prevent;

function renderItem(_value, data) {
  return data;
}

function mapItems(fn, items) {
  var result = [];
  var index = 0;

  for (var _iterator = items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var entry = _ref;

    var _normalizeEntry = normalizeEntry(entry),
        _value2 = _normalizeEntry[0],
        _data = _normalizeEntry[1];

    result.push(fn(_value2, _data, index));
    ++index;
  }

  return result;
}

function normalizeEntry(entry) {
  if (!Array.isArray(entry)) {
    return [entry, entry];
  }

  return entry;
}