import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";

var _dec, _class, _class2, _temp;

import React from 'react';
import cn from 'classnames';
import { ConditionalHandler } from "../../../lib/ConditionalHandler";
import { LENGTH_FULLDATE, MAX_FULLDATE, MIN_FULLDATE } from "../../../lib/date/constants";
import { InternalDateComponentType } from "../../../lib/date/types";
import { DatePickerLocaleHelper } from "../../DatePicker/locale";
import { InputLikeText } from "../../../internal/InputLikeText";
import { locale } from "../../../lib/locale/decorators";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { CalendarIcon } from "../../../internal/icons/16px";
import { DateFragmentsView } from "../DateFragmentsView";
import { jsStyles } from "../DateInput.styles";
import { Actions, extractAction } from "../helpers/DateInputKeyboardActions";
import { InternalDateMediator } from "../helpers/InternalDateMediator";
export var DateInput = (_dec = locale('DatePicker', DatePickerLocaleHelper), _dec(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(DateInput, _React$Component);

  function DateInput(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.iDateMediator = new InternalDateMediator();
    _this.inputLikeText = null;
    _this.dateFragmentsView = null;
    _this.isMouseDown = false;
    _this.isMouseFocus = false;
    _this.ignoringDelimiter = false;
    _this.locale = void 0;
    _this.blurEvent = null;
    _this.theme = void 0;
    _this.conditionalHandler = new ConditionalHandler().add(Actions.MoveSelectionLeft, function () {
      return _this.shiftSelection(-1);
    }).add(Actions.MoveSelectionRight, function () {
      return _this.shiftSelection(1);
    }).add(Actions.Separator, function () {
      return _this.pressDelimiter();
    }).add(Actions.MoveSelectionFirst, function () {
      return _this.selectDateComponent(_this.iDateMediator.getLeftmostType());
    }).add(Actions.MoveSelectionLast, function () {
      return _this.selectDateComponent(_this.iDateMediator.getRightmostType());
    }).add(Actions.Increment, function () {
      return _this.shiftDateComponent(1);
    }).add(Actions.Decrement, function () {
      return _this.shiftDateComponent(-1);
    }).add(Actions.Digit, function (e) {
      return _this.inputValue(e);
    }).add(Actions.ClearSelection, function () {
      return _this.clearSelected();
    }).add(Actions.ClearOneChar, function () {
      return _this.clearOneChar();
    }).add(Actions.FullSelection, function () {
      return _this.fullSelection();
    }).add(Actions.WrongInput, function () {
      return _this.blink();
    }).build();

    _this.selectNode = function () {
      var type = _this.state.selected;

      var dateFragmentsView = _this.dateFragmentsView && _this.dateFragmentsView.getRootNode();

      if (type === null || !_this.inputLikeText || !dateFragmentsView) {
        return;
      }

      if (type === InternalDateComponentType.All) {
        _this.inputLikeText.selectInnerNode(dateFragmentsView, 0, 5);

        return;
      }

      var index = _this.iDateMediator.getTypesOrder().indexOf(type);

      if (index > -1) {
        _this.inputLikeText.selectInnerNode(dateFragmentsView, index * 2, index * 2 + 1);
      }
    };

    _this.renderIcon = function () {
      var _this$props = _this.props,
          withIcon = _this$props.withIcon,
          size = _this$props.size,
          _this$props$disabled = _this$props.disabled,
          disabled = _this$props$disabled === void 0 ? false : _this$props$disabled;

      if (withIcon) {
        var _cn;

        var theme = _this.theme;
        var iconStyles = cn((_cn = {}, _cn[jsStyles.icon(theme)] = true, _cn[jsStyles.iconSmall(theme)] = size === 'small', _cn[jsStyles.iconMedium(theme)] = size === 'medium', _cn[jsStyles.iconLarge(theme)] = size === 'large', _cn[jsStyles.iconDisabled(theme)] = disabled, _cn));
        return React.createElement("span", {
          className: iconStyles
        }, React.createElement(CalendarIcon, null));
      }

      return null;
    };

    _this.handleFocus = function (e) {
      _this.setState(function (prevState) {
        return {
          focused: true,
          selected: _this.isMouseDown && !prevState.focused ? prevState.selected : _this.iDateMediator.getLeftmostType()
        };
      });

      if (_this.props.onFocus) {
        _this.props.onFocus(e);
      }
    };

    _this.handleBlur = function (e) {
      var restored = _this.iDateMediator.restore();

      _this.updateValue({
        focused: false,
        selected: null,
        inputMode: false
      });

      if (_this.props.onBlur) {
        if (restored) {
          e.persist();
          _this.blurEvent = e;
        } else {
          _this.props.onBlur(e);
        }
      }
    };

    _this.handleMouseDownCapture = function (e) {
      var isFragment = _this.dateFragmentsView ? _this.dateFragmentsView.isFragment(e.target) : false;

      if (_this.state.focused && !isFragment) {
        e.preventDefault();
      }

      _this.isMouseFocus = !_this.state.focused;
      _this.isMouseDown = isFragment;
    };

    _this.handleSelectDateComponent = function (type) {
      if (!(_this.isMouseFocus && _this.iDateMediator.isEmpty())) {
        _this.selectDateComponent(type);
      }

      _this.isMouseFocus = false;
      _this.isMouseDown = false;
    };

    _this.handleMouseDragStart = function () {
      _this.setState({
        dragged: true,
        selected: null
      });
    };

    _this.handleMouseDragEnd = function () {
      var selection = getSelection();

      if (selection && selection.toString().length === LENGTH_FULLDATE && _this.state.selected !== InternalDateComponentType.All) {
        _this.selectDateComponent(InternalDateComponentType.All);
      }
    };

    _this.handleKeyDown = function (e) {
      if (_this.conditionalHandler(extractAction(e), e)) {
        e.preventDefault();
      }

      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }
    };

    _this.handlePaste = function (e) {
      var pasted = e && e.clipboardData.getData('text').trim();

      if (pasted && _this.iDateMediator.validateString(pasted)) {
        _this.iDateMediator.paste(pasted);

        _this.updateValue();
      }
    };

    _this.handleDoubleClick = function () {
      _this.selectDateComponent(InternalDateComponentType.All);
    };

    _this.inputLikeTextRef = function (el) {
      _this.inputLikeText = el;
    };

    _this.dateFragmentsViewRef = function (el) {
      _this.dateFragmentsView = el;
    };

    _this.selectDateComponent = function (selected) {
      _this.setState({
        selected: selected,
        inputMode: false
      });
    };

    _this.updateValue = function (state) {
      if (state === void 0) {
        state = {};
      }

      var valueFormatted = _this.iDateMediator.getString();

      _this.setState(_extends({}, state, {
        valueFormatted: valueFormatted
      }), _this.emitChange);
    };

    _this.updateFromProps = function () {
      _this.iDateMediator.update(_this.props, _this.locale);

      _this.updateValue();
    };

    _this.fullSelection = function () {
      _this.selectDateComponent(InternalDateComponentType.All);
    };

    _this.pressDelimiter = function () {
      var value = _this.iDateMediator.get(_this.state.selected);

      if (value !== null && value !== '') {
        if (!_this.ignoringDelimiter) {
          _this.shiftSelection(1);
        }

        _this.ignoringDelimiter = false;
      }
    };

    _this.emitChange = function () {
      var value = _this.iDateMediator.getInternalString();

      if (_this.props.value === value) {
        return;
      }

      if (_this.props.onValueChange) {
        _this.props.onValueChange(value);
      }

      if (_this.blurEvent && _this.props.onBlur) {
        _this.props.onBlur(_this.blurEvent);

        _this.blurEvent = null;
      }
    };

    _this.clearSelected = function () {
      var selected = _this.state.selected === null ? _this.iDateMediator.getLeftmostType() : _this.state.selected;

      _this.iDateMediator.clear(selected);

      _this.updateValue({
        inputMode: false,
        selected: selected === InternalDateComponentType.All ? _this.iDateMediator.getLeftmostType() : selected
      });
    };

    _this.clearOneChar = function () {
      var _this$state = _this.state,
          selected = _this$state.selected,
          inputMode = _this$state.inputMode;
      var nextType = selected === null ? _this.iDateMediator.getRightmostType() : selected;

      if (_this.iDateMediator.isNull(nextType)) {
        _this.shiftSelection(-1);

        return;
      }

      if (selected === InternalDateComponentType.All) {
        _this.iDateMediator.clear(InternalDateComponentType.All);

        _this.updateValue({
          selected: _this.iDateMediator.getLeftmostType()
        });

        return;
      }

      _this.iDateMediator.deleteOneCharRight(nextType, inputMode);

      _this.updateValue({
        inputMode: _this.iDateMediator.get(nextType) !== null,
        selected: nextType
      });
    };

    _this.shiftDateComponent = function (step) {
      var selected = _this.state.selected;

      var changed = _this.iDateMediator.shiftDateComponent(selected, step);

      if (!changed) {
        _this.blink();

        return;
      }

      _this.updateValue({
        inputMode: false,
        selected: selected === InternalDateComponentType.All ? _this.iDateMediator.getLeftmostType() : selected
      });
    };

    _this.shiftSelection = function (step) {
      var selected = _this.iDateMediator.getShiftedType(_this.state.selected, step);

      if (selected !== _this.state.selected) {
        _this.setState({
          selected: selected,
          inputMode: false
        });
      }
    };

    _this.inputValue = function (event) {
      var selected = _this.state.selected;

      if (selected === InternalDateComponentType.All) {
        selected = _this.iDateMediator.getLeftmostType();

        _this.iDateMediator.clear(InternalDateComponentType.All);

        _this.setState({
          selected: selected
        });
      }

      var inputMode = _this.iDateMediator.inputKey(event.key, selected, _this.state.inputMode);

      if (!inputMode) {
        _this.ignoringDelimiter = true;

        _this.shiftSelection(1);
      }

      _this.updateValue({
        inputMode: inputMode
      });
    };

    _this.state = {
      valueFormatted: '',
      selected: null,
      inputMode: false,
      focused: false,
      dragged: false
    };
    return _this;
  }

  var _proto = DateInput.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.value !== this.props.value || prevProps.minDate !== this.props.minDate || prevProps.maxDate !== this.props.maxDate || this.iDateMediator.isChangedLocale(this.locale)) {
      this.updateFromProps();
    }

    this.selectNode();
  };

  _proto.componentDidMount = function componentDidMount() {
    this.updateFromProps();
  };

  _proto.blur = function blur() {
    if (this.inputLikeText) {
      this.inputLikeText.blur();
    }
  };

  _proto.focus = function focus() {
    if (this.inputLikeText) {
      this.inputLikeText.focus();
    }
  };

  _proto.blink = function blink() {
    if (this.inputLikeText) {
      this.inputLikeText.blink();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  };

  _proto.renderMain = function renderMain() {
    var _this$state2 = this.state,
        focused = _this$state2.focused,
        selected = _this$state2.selected,
        inputMode = _this$state2.inputMode,
        valueFormatted = _this$state2.valueFormatted;
    var fragments = focused || valueFormatted !== '' ? this.iDateMediator.getFragments() : [];
    return React.createElement(InputLikeText, {
      width: this.props.width,
      ref: this.inputLikeTextRef,
      size: this.props.size,
      disabled: this.props.disabled,
      error: this.props.error,
      warning: this.props.warning,
      onBlur: this.handleBlur,
      onFocus: this.handleFocus,
      onKeyDown: this.handleKeyDown,
      onMouseDownCapture: this.handleMouseDownCapture,
      onPaste: this.handlePaste,
      rightIcon: this.renderIcon(),
      onDoubleClickCapture: this.handleDoubleClick,
      onMouseDragStart: this.handleMouseDragStart,
      onMouseDragEnd: this.handleMouseDragEnd,
      value: this.iDateMediator.getInternalString()
    }, React.createElement(DateFragmentsView, {
      ref: this.dateFragmentsViewRef,
      fragments: fragments,
      onSelectDateComponent: this.handleSelectDateComponent,
      selected: selected,
      inputMode: inputMode
    }));
  };

  return DateInput;
}(React.Component), _class2.__KONTUR_REACT_UI__ = 'DateInput', _class2.defaultProps = {
  value: '',
  minDate: MIN_FULLDATE,
  maxDate: MAX_FULLDATE,
  size: 'small',
  width: 125
}, _temp)) || _class);