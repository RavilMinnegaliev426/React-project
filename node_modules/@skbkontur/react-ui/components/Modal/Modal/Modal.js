import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import FocusLock from 'react-focus-lock';
import cn from 'classnames';
import { isKeyEscape } from "../../../lib/events/keyboard/identifiers";
import * as LayoutEvents from "../../../lib/LayoutEvents";
import { RenderContainer } from "../../../internal/RenderContainer";
import { ZIndex } from "../../../internal/ZIndex";
import { stopPropagation } from "../../../lib/events/stopPropagation";
import { HideBodyVerticalScroll } from "../../../internal/HideBodyVerticalScroll";
import { ModalStack } from "../../../lib/ModalStack";
import { ResizeDetector } from "../../../internal/ResizeDetector";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { isIE11 } from "../../../lib/utils";
import { ModalContext } from "../ModalContext";
import { ModalFooter } from "../ModalFooter";
import { ModalHeader } from "../ModalHeader";
import { isBody, isFooter, isHeader } from "../helpers";
import { ModalBody } from "../ModalBody";
import { ModalClose } from "../ModalClose";
import { jsStyles } from "../Modal.styles";
var mountedModalsCount = 0;
/**
                             * Модальное окно
                             *
                             * Содержит в себе три компоненты: **Modal.Header**,
                             * **Modal.Body** и **Modal.Footer**
                             *
                             * Для отображения серой плашки в футере в компонент
                             * **Footer** необходимо передать пропс **panel**
                             *
                             * Для отключения прилипания шапки и футера
                             * в соответствующий компонет нужно передать
                             * проп **sticky** со значением **false**
                             * (по-умолчанию прилипание включено)
                             */

export var Modal =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Modal, _React$Component);

  function Modal() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      stackPosition: 0,
      horizontalScroll: false
    };
    _this.theme = void 0;
    _this.stackSubscription = null;
    _this.containerNode = null;
    _this.mouseDownTarget = null;
    _this.mouseUpTarget = null;

    _this.requestClose = function () {
      if (_this.props.disableClose) {
        return;
      }

      if (_this.props.onClose) {
        _this.props.onClose();
      }
    };

    _this.refContainer = function (center) {
      _this.containerNode = center;
    };

    _this.handleStackChange = function (stack) {
      _this.setState({
        stackPosition: stack.indexOf(_assertThisInitialized(_this))
      });
    };

    _this.handleContainerMouseDown = function (event) {
      _this.mouseDownTarget = event.target;
    };

    _this.handleContainerMouseUp = function (event) {
      _this.mouseUpTarget = event.target;
    };

    _this.handleContainerClick = function (event) {
      if (!_this.props.ignoreBackgroundClick) {
        var target = event.target,
            currentTarget = event.currentTarget;

        if (target === currentTarget && _this.mouseDownTarget === currentTarget && _this.mouseUpTarget === currentTarget) {
          _this.requestClose();
        }
      }
    };

    _this.handleKeyDown = function (e) {
      if (_this.state.stackPosition !== 0) {
        return;
      }

      if (isKeyEscape(e)) {
        stopPropagation(e);

        _this.requestClose();
      }
    };

    _this.checkHorizontalScrollAppearance = function () {
      var hasScroll = false;

      if (_this.containerNode) {
        var containerClientWidth = _this.containerNode.clientWidth;
        var containerScrollWidth = _this.containerNode.scrollWidth;
        hasScroll = containerClientWidth < containerScrollWidth;
      }

      if (hasScroll && !_this.state.horizontalScroll) {
        _this.setState({
          horizontalScroll: true
        });
      } else if (_this.state.horizontalScroll) {
        _this.setState({
          horizontalScroll: false
        });
      }
    };

    _this.handleResize = function (event) {
      LayoutEvents.emit();
    };

    return _this;
  }

  var _proto = Modal.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.stackSubscription = ModalStack.add(this, this.handleStackChange);

    if (mountedModalsCount === 0) {
      window.addEventListener('resize', this.checkHorizontalScrollAppearance);
    }

    mountedModalsCount++;
    window.addEventListener('keydown', this.handleKeyDown);
    this.checkHorizontalScrollAppearance();

    if (this.containerNode) {
      this.containerNode.addEventListener('scroll', LayoutEvents.emit);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (--mountedModalsCount === 0) {
      window.removeEventListener('resize', this.checkHorizontalScrollAppearance);
      LayoutEvents.emit();
    }

    window.removeEventListener('keydown', this.handleKeyDown);

    if (this.stackSubscription != null) {
      this.stackSubscription.remove();
    }

    ModalStack.remove(this);

    if (this.containerNode) {
      this.containerNode.removeEventListener('scroll', LayoutEvents.emit);
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  };

  _proto.renderMain = function renderMain() {
    var _cn;

    var hasHeader = false;
    var hasFooter = false;
    var hasPanel = false;
    React.Children.toArray(this.props.children).forEach(function (child) {
      if (isHeader(child)) {
        hasHeader = true;
      }

      if (isFooter(child)) {
        hasFooter = true;

        if (child.props.panel) {
          hasPanel = true;
        }
      }
    });
    var modalContextProps = {
      hasHeader: hasHeader,
      horizontalScroll: this.state.horizontalScroll
    };

    if (hasHeader && !this.props.noClose) {
      modalContextProps.close = {
        disableClose: this.props.disableClose,
        requestClose: this.requestClose
      };
    }

    if (!hasFooter) {
      modalContextProps.additionalPadding = true;
    }

    if (hasFooter && hasPanel) {
      modalContextProps.additionalPadding = true;
    }

    var style = {};
    var containerStyle = {};

    if (this.props.width) {
      style.width = this.props.width;
    } else {
      containerStyle.width = 'auto';
    }

    return React.createElement(RenderContainer, null, React.createElement(ZIndex, {
      priority: 'Modal',
      className: jsStyles.root()
    }, React.createElement(HideBodyVerticalScroll, null), this.state.stackPosition === 0 && React.createElement("div", {
      className: jsStyles.bg(this.theme)
    }), React.createElement("div", {
      ref: this.refContainer,
      className: jsStyles.container(),
      onMouseDown: this.handleContainerMouseDown,
      onMouseUp: this.handleContainerMouseUp,
      onClick: this.handleContainerClick,
      "data-tid": "modal-container"
    }, React.createElement("div", {
      className: cn((_cn = {}, _cn[jsStyles.centerContainer(this.theme)] = true, _cn[jsStyles.alignTop(this.theme)] = Boolean(this.props.alignTop), _cn)),
      style: containerStyle,
      "data-tid": "modal-content"
    }, React.createElement("div", {
      className: jsStyles.window(this.theme),
      style: style
    }, React.createElement(ResizeDetector, {
      onResize: this.handleResize
    }, React.createElement(FocusLock, {
      disabled: this.props.disableFocusLock,
      autoFocus: false
    }, !hasHeader && !this.props.noClose ? React.createElement(ZIndex, {
      priority: 'ModalCross',
      className: jsStyles.closeWrapper()
    }, React.createElement(ModalClose, {
      requestClose: this.requestClose,
      disableClose: this.props.disableClose
    })) : null, React.createElement(ModalContext.Provider, {
      value: modalContextProps
    }, this.props.children))))))));
  };

  return Modal;
}(React.Component);
Modal.__KONTUR_REACT_UI__ = 'Modal';
Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;
Modal.propTypes = {
  children: function children(props, propName, componentName) {
    if (React.Children.toArray(props[propName]).some(function (child) {
      return !isHeader(child) && !isBody(child) && !isFooter(child);
    })) {
      return new Error("Only 'Header/Body/Footer' components are allowed for '" + propName + "' prop of '" + componentName + "' component");
    }
  }
};
Modal.defaultProps = {
  // NOTE: в ie нормально не работает
  disableFocusLock: isIE11
};