import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import shallowEqual from 'shallowequal';
import cn from 'classnames';
import * as LayoutEvents from "../../../lib/LayoutEvents";
import { isFunction } from "../../../lib/utils";
import { ZIndex } from "../../../internal/ZIndex";
import { jsStyles } from "../Sticky.styles";
var MAX_REFLOW_RETRIES = 5;
export var Sticky =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Sticky, _React$Component);

  function Sticky() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      fixed: false,
      deltaHeight: 0,
      stopped: false,
      relativeTop: 0
    };
    _this.wrapper = void 0;
    _this.inner = void 0;
    _this.layoutSubscription = {
      remove: null
    };
    _this.reflowCounter = 0;

    _this.refWrapper = function (ref) {
      return _this.wrapper = ref;
    };

    _this.refInner = function (ref) {
      return _this.inner = ref;
    };

    _this.reflow = function () {
      var _document = document,
          documentElement = _document.documentElement;

      if (!documentElement) {
        throw Error('There is no "documentElement" in document');
      }

      var windowHeight = window.innerHeight || documentElement.clientHeight;

      if (!_this.wrapper || !_this.inner) {
        return;
      }

      var _this$wrapper$getBoun = _this.wrapper.getBoundingClientRect(),
          top = _this$wrapper$getBoun.top,
          bottom = _this$wrapper$getBoun.bottom,
          left = _this$wrapper$getBoun.left;

      var _this$inner$getBoundi = _this.inner.getBoundingClientRect(),
          width = _this$inner$getBoundi.width,
          height = _this$inner$getBoundi.height;

      var _this$props = _this.props,
          offset = _this$props.offset,
          getStop = _this$props.getStop,
          side = _this$props.side;
      var _this$state = _this.state,
          prevFixed = _this$state.fixed,
          _this$state$height = _this$state.height,
          prevHeight = _this$state$height === void 0 ? height : _this$state$height;
      var fixed = side === 'top' ? top < offset : bottom > windowHeight - offset;

      _this.setState({
        fixed: fixed,
        left: left
      });

      if (fixed && !prevFixed) {
        _this.setState({
          width: width,
          height: height
        });
      }

      if (fixed) {
        var stop = getStop && getStop();

        if (stop) {
          var deltaHeight = prevHeight - height;
          var stopRect = stop.getBoundingClientRect();
          var outerHeight = height + offset;
          var stopped = false;
          var relativeTop = 0;

          if (side === 'top') {
            stopped = stopRect.top - outerHeight < 0;
            relativeTop = stopRect.top - height - top;
          } else {
            stopped = stopRect.bottom + outerHeight > windowHeight;
            relativeTop = stopRect.bottom - top;
          }

          _this.setState({
            relativeTop: relativeTop,
            deltaHeight: deltaHeight,
            stopped: stopped
          });
        }
      }
    };

    return _this;
  }

  var _proto = Sticky.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.reflow();
    this.layoutSubscription = LayoutEvents.addListener(this.reflow);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.layoutSubscription.remove) {
      this.layoutSubscription.remove();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (!shallowEqual(prevProps, this.props) || !shallowEqual(prevState, this.state)) {
      if (this.reflowCounter < MAX_REFLOW_RETRIES) {
        LayoutEvents.emit();
        this.reflowCounter += 1;
        return;
      }
    }

    this.reflowCounter = 0;
  };

  _proto.render = function render() {
    var _cn;

    var children = this.props.children;
    var _this$props2 = this.props,
        side = _this$props2.side,
        offset = _this$props2.offset;
    var _this$state2 = this.state,
        fixed = _this$state2.fixed,
        stopped = _this$state2.stopped,
        relativeTop = _this$state2.relativeTop,
        deltaHeight = _this$state2.deltaHeight,
        width = _this$state2.width,
        height = _this$state2.height,
        left = _this$state2.left;
    var innerStyle = {};

    if (fixed) {
      if (stopped) {
        innerStyle.top = relativeTop;
        innerStyle[side === 'top' ? 'marginTop' : 'marginBottom'] = deltaHeight;
      } else {
        innerStyle.width = width;
        innerStyle[side] = offset;
        innerStyle.left = left;
      }
    }

    if (isFunction(children)) {
      children = children(fixed);
    }

    return React.createElement("div", {
      ref: this.refWrapper
    }, React.createElement(ZIndex, {
      priority: "Sticky",
      applyZIndex: fixed,
      className: cn(jsStyles.inner(), (_cn = {}, _cn[jsStyles.fixed()] = fixed && !stopped, _cn[jsStyles.stopped()] = stopped, _cn)),
      style: innerStyle,
      wrapperRef: this.refInner
    }, React.createElement("div", {
      className: jsStyles.container()
    }, children)), fixed && !stopped ? React.createElement("div", {
      style: {
        width: width,
        height: height
      }
    }) : null);
  };

  return Sticky;
}(React.Component);
Sticky.__KONTUR_REACT_UI__ = 'Sticky';
Sticky.propTypes = {
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Функция, которая возвращает DOM-элемент, который нельзя пересекать.
   */
  getStop: PropTypes.func,

  /**
   * Отступ от границы в пикселях
   */
  offset: PropTypes.number,
  side: PropTypes.oneOf(['top', 'bottom']).isRequired
};
Sticky.defaultProps = {
  offset: 0
};