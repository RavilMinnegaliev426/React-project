import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import PropTypes from 'prop-types';
import React from 'react';
import { findDOMNode } from 'react-dom';
import { InternalDate } from "../../../lib/date/InternalDate";
import { InternalDateTransformer } from "../../../lib/date/InternalDateTransformer";
import { MAX_FULLDATE, MIN_FULLDATE } from "../../../lib/date/constants";
import { InternalDateOrder, InternalDateSeparator, InternalDateValidateCheck } from "../../../lib/date/types";
import { DateInput } from "../../DateInput";
import { DropdownContainer } from "../../../internal/DropdownContainer";
import { filterProps } from "../../../lib/filterProps";
import { Picker } from "../Picker";
import { jsStyles } from "../DatePicker.styles";
var INPUT_PASS_PROPS = {
  autoFocus: true,
  disabled: true,
  warning: true,
  error: true,
  size: true,
  onKeyDown: true
};
export var DatePicker =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(DatePicker, _React$Component);

  function DatePicker() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      opened: false
    };
    _this.input = null;
    _this.focused = false;
    _this.internalDate = _this.parseValueToDate(_this.props.value);
    _this.minDate = _this.parseValueToDate(_this.props.minDate);
    _this.maxDate = _this.parseValueToDate(_this.props.maxDate);

    _this.getInputRef = function (ref) {
      _this.input = ref;
    };

    _this.handleFocus = function () {
      if (_this.focused) {
        return;
      }

      _this.focused = true;

      _this.setState({
        opened: true
      });

      if (_this.props.onFocus) {
        _this.props.onFocus();
      }
    };

    _this.handleBlur = function () {
      if (!_this.focused) {
        return;
      }

      _this.focused = false;

      _this.close();

      if (_this.props.onBlur) {
        _this.props.onBlur();
      }
    };

    _this.handlePick = function (dateShape) {
      _this.handleSelect(dateShape);

      _this.blur();
    };

    _this.handleSelect = function (_ref) {
      var date = _ref.date,
          month = _ref.month,
          year = _ref.year;
      var value = InternalDateTransformer.dateToInternalString({
        date: date,
        month: month + 1,
        year: year
      });

      if (_this.props.onValueChange) {
        _this.props.onValueChange(value);
      }
    };

    _this.isHoliday = function (_ref2) {
      var date = _ref2.date,
          month = _ref2.month,
          year = _ref2.year,
          isWeekend = _ref2.isWeekend;
      var dateString = InternalDateTransformer.dateToInternalString({
        date: date,
        month: month + 1,
        year: year
      });
      return _this.props.isHoliday(dateString, isWeekend);
    };

    return _this;
  }

  var _proto = DatePicker.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.autoFocus) {
      this.focus();
    }
  };

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    var disabled = nextProps.disabled;
    var opened = this.state.opened;

    if (disabled && opened) {
      this.close();
    }

    this.internalDate = this.parseValueToDate(nextProps.value);
    this.minDate = this.parseValueToDate(nextProps.minDate);
    this.maxDate = this.parseValueToDate(nextProps.maxDate);
  }
  /**
   * @public
   */
  ;

  _proto.blur = function blur() {
    if (this.input) {
      this.input.blur();
    }

    this.handleBlur();
  }
  /**
   * @public
   */
  ;

  _proto.focus = function focus() {
    if (this.props.disabled) {
      return;
    }

    if (this.input) {
      this.input.focus();
    }

    this.handleFocus();
  }
  /**
   * Закрывает выпадашку выбора дня
   * @public
   */
  ;

  _proto.close = function close() {
    this.setState({
      opened: false
    });
  };

  _proto.render = function render() {
    var _this2 = this;

    var picker = null;
    var date = this.internalDate ? this.internalDate.toNativeFormat() : null;

    if (this.state.opened) {
      picker = React.createElement(DropdownContainer, {
        getParent: function getParent() {
          return findDOMNode(_this2);
        },
        offsetY: 2,
        align: this.props.menuAlign
      }, React.createElement(Picker, {
        value: date,
        minDate: this.minDate && this.minDate.toNativeFormat() || undefined,
        maxDate: this.maxDate && this.maxDate.toNativeFormat() || undefined,
        onPick: this.handlePick,
        onSelect: this.handleSelect,
        enableTodayLink: this.props.enableTodayLink,
        isHoliday: this.isHoliday
      }));
    }

    return React.createElement("label", {
      className: jsStyles.root(),
      style: {
        width: this.props.width
      },
      onMouseEnter: this.props.onMouseEnter,
      onMouseLeave: this.props.onMouseLeave,
      onMouseOver: this.props.onMouseOver
    }, React.createElement(DateInput, _extends({}, filterProps(this.props, INPUT_PASS_PROPS), {
      ref: this.getInputRef,
      value: this.props.value || '',
      width: "100%",
      withIcon: true,
      minDate: this.props.minDate,
      maxDate: this.props.maxDate,
      onBlur: this.handleBlur,
      onFocus: this.handleFocus,
      onValueChange: this.props.onValueChange
    })), picker);
  };

  _proto.parseValueToDate = function parseValueToDate(value) {
    if (value === undefined || value === null) {
      return undefined;
    }

    var date = new InternalDate({
      value: value
    });

    if (date.validate({
      checks: [InternalDateValidateCheck.NotNull, InternalDateValidateCheck.Native]
    })) {
      return date;
    }

    return undefined;
  };

  return DatePicker;
}(React.Component);
DatePicker.__KONTUR_REACT_UI__ = 'DatePicker';
DatePicker.propTypes = {
  autoFocus: PropTypes.bool,
  disabled: PropTypes.bool,

  /**
   * Включает кнопку сегодня в календаре
   */
  enableTodayLink: PropTypes.bool,
  error: PropTypes.bool,

  /**
   * Максимальная дата в календаре.
   */
  maxDate: PropTypes.string.isRequired,
  menuAlign: PropTypes.oneOf(['left', 'right']),

  /**
   * Минимальная дата в календаре.
   */
  minDate: PropTypes.string.isRequired,

  /**
   * Строка формата `dd.mm.yyyy`
   */
  value: PropTypes.string,
  warning: PropTypes.bool,
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
  onBlur: PropTypes.func,
  onValueChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  onKeyDown: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onMouseOver: PropTypes.func,
  isHoliday: PropTypes.func.isRequired
};
DatePicker.defaultProps = {
  width: 120,
  minDate: MIN_FULLDATE,
  maxDate: MAX_FULLDATE,
  isHoliday: function isHoliday(_day, isWeekend) {
    return isWeekend;
  }
};

DatePicker.validate = function (value, range) {
  if (range === void 0) {
    range = {};
  }

  if (!value) {
    return false;
  }

  var _range = range,
      _range$minDate = _range.minDate,
      minDate = _range$minDate === void 0 ? MIN_FULLDATE : _range$minDate,
      _range$maxDate = _range.maxDate,
      maxDate = _range$maxDate === void 0 ? MAX_FULLDATE : _range$maxDate;
  var internalDate = new InternalDate({
    order: InternalDateOrder.DMY,
    separator: InternalDateSeparator.Dot
  }).setRangeStart(new InternalDate({
    value: minDate
  })).setRangeEnd(new InternalDate({
    value: maxDate
  })).parseValue(value);
  return internalDate.validate({
    checks: [InternalDateValidateCheck.NotNull, InternalDateValidateCheck.Number, InternalDateValidateCheck.Native, InternalDateValidateCheck.Limits, InternalDateValidateCheck.Range]
  });
};