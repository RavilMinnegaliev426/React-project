import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import { findDOMNode } from 'react-dom';
import { isKeyArrowDown, isKeyArrowUp, isKeyEnter, isKeyEscape } from "../../../lib/events/keyboard/identifiers";
import { Input } from "../../Input";
import { DropdownContainer } from "../../../internal/DropdownContainer";
import { Menu } from "../../../internal/Menu";
import { MenuItem } from "../../MenuItem";
import { RenderLayer } from "../../../internal/RenderLayer";
import { createPropsGetter } from "../../../lib/createPropsGetter";
import { fixClickFocusIE } from "../../../lib/events/fixClickFocusIE";

function match(pattern, items) {
  if (!pattern || !items) {
    return Promise.resolve([]);
  }

  pattern = pattern.toLowerCase();
  var filteredItems = items.filter(function (item) {
    return item.toLowerCase().includes(pattern);
  });
  return Promise.resolve(filteredItems);
}

function renderItem(item) {
  return item;
}
/**
   * Стандартный инпут с подсказками.
   *
   * Все свойства передаются во внутренний *Input*.
   */


export var Autocomplete =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Autocomplete, _React$Component);

  function Autocomplete() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      items: null,
      selected: -1
    };
    _this.opened = false;
    _this.input = null;
    _this.menu = void 0;
    _this.focused = false;
    _this.requestId = 0;
    _this.getProps = createPropsGetter(Autocomplete.defaultProps);

    _this.handleValueChange = function (value) {
      _this.opened = true;

      _this.fireChange(value);
    };

    _this.handleFocus = function (event) {
      if (_this.focused) {
        return;
      }

      _this.focused = true;

      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };

    _this.handleBlur = function () {
      if (!_this.focused) {
        return;
      }

      _this.focused = false;
      _this.opened = false;

      _this.setState({
        items: null
      });

      if (_this.input) {
        _this.input.blur();
      }

      if (_this.props.onBlur) {
        _this.props.onBlur();
      }
    };

    _this.handleClickOutside = function (e) {
      fixClickFocusIE(e);

      _this.handleBlur();
    };

    _this.handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }

      switch (true) {
        case isKeyEscape(e):
          e.preventDefault();

          _this.setState({
            items: null
          });

          return;

        case isKeyArrowUp(e):
          e.preventDefault();

          if (_this.menu) {
            _this.menu.up();
          }

          return;

        case isKeyArrowDown(e):
          e.preventDefault();

          if (_this.menu) {
            _this.menu.down();
          }

          return;

        case isKeyEnter(e):
          e.preventDefault(); // To prevent form submission.

          if (_this.menu) {
            _this.menu.enter(e);
          }

          return;
      }
    };

    _this.getAnchor = function () {
      return findDOMNode(_assertThisInitialized(_this));
    };

    _this.refInput = function (el) {
      _this.input = el;
    };

    _this.refMenu = function (menu) {
      _this.menu = menu;
    };

    return _this;
  }

  var _proto = Autocomplete.prototype;
  /**
   * @public
   */

  _proto.focus = function focus() {
    if (this.input) {
      this.input.focus();
    }
  }
  /**
   * @public
   */
  ;

  _proto.blur = function blur() {
    this.handleBlur();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.value !== this.props.value) {
      this.updateItems(this.props.value || '');
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        onValueChange = _this$props.onValueChange,
        onKeyDown = _this$props.onKeyDown,
        onFocus = _this$props.onFocus,
        onBlur = _this$props.onBlur,
        _renderItem = _this$props.renderItem,
        disablePortal = _this$props.disablePortal,
        hasShadow = _this$props.hasShadow,
        menuAlign = _this$props.menuAlign,
        menuMaxHeight = _this$props.menuMaxHeight,
        preventWindowScroll = _this$props.preventWindowScroll,
        source = _this$props.source,
        rest = _objectWithoutPropertiesLoose(_this$props, ["onValueChange", "onKeyDown", "onFocus", "onBlur", "renderItem", "disablePortal", "hasShadow", "menuAlign", "menuMaxHeight", "preventWindowScroll", "source"]);

    var inputProps = _extends({}, rest, {
      onValueChange: this.handleValueChange,
      onKeyDown: this.handleKeyDown,
      onFocus: this.handleFocus,
      ref: this.refInput
    });

    return React.createElement(RenderLayer, {
      onFocusOutside: this.handleBlur,
      onClickOutside: this.handleClickOutside
    }, React.createElement("span", {
      style: {
        display: 'inline-block'
      }
    }, React.createElement(Input, inputProps), this.renderMenu()));
  };

  _proto.renderMenu = function renderMenu() {
    var _this2 = this;

    var items = this.state.items;
    var menuProps = {
      ref: this.refMenu,
      maxHeight: this.props.menuMaxHeight,
      hasShadow: this.props.hasShadow,
      width: this.props.menuWidth || this.props.width,
      preventWindowScroll: this.props.preventWindowScroll
    };

    if (!items || items.length === 0) {
      return null;
    }

    return React.createElement(DropdownContainer, {
      offsetY: 1,
      getParent: this.getAnchor,
      align: this.props.menuAlign,
      disablePortal: this.props.disablePortal
    }, React.createElement(Menu, menuProps, items.map(function (item, i) {
      return React.createElement(MenuItem, {
        onClick: _this2.handleMenuItemClick(i),
        key: i
      }, _this2.getProps().renderItem(item));
    })));
  };

  _proto.handleMenuItemClick = function handleMenuItemClick(i) {
    var _this3 = this;

    return function (event) {
      return _this3.handleItemClick(event, i);
    };
  };

  _proto.handleItemClick = function handleItemClick(event, index) {
    if (event.button) {
      return;
    }

    event.preventDefault();
    this.choose(index);
  };

  _proto.choose = function choose(index) {
    if (!this.state.items) {
      return;
    }

    var value = this.state.items[index];
    this.opened = false;
    this.setState({
      selected: -1,
      items: null
    });
    this.fireChange(value);
    this.blur();
  };

  _proto.updateItems = function updateItems(value) {
    var _this4 = this;

    if (!this.opened) {
      return;
    }

    var pattern = value.trim();
    var source = this.props.source;

    if (!source) {
      return;
    }

    var promise;
    var expectingId = this.requestId += 1;

    if (typeof source === 'function') {
      promise = source(pattern);
    } else {
      promise = match(pattern, source);
    }

    promise.then(function (items) {
      if (_this4.opened && expectingId === _this4.requestId) {
        _this4.setState({
          items: items,
          selected: -1
        });
      }
    });
  };

  _proto.fireChange = function fireChange(value) {
    if (this.props.onValueChange) {
      this.props.onValueChange(value);
    }
  };

  return Autocomplete;
}(React.Component);
Autocomplete.__KONTUR_REACT_UI__ = 'Autocomplete';
Autocomplete.propTypes = {
  /**
   * Функция для отрисовки элемента в выпадающем списке. Единственный аргумент
   * — *item*.
   */
  renderItem: PropTypes.func,

  /**
   * Если передан массив, то совпадения ищутся по этому массиву.
   *
   * Если передается функция, то она должна возвращать thenable, который
   * резолвится уже отфильтрованным массивом. Возвращенный thenable может
   * иметь метод cancel, который будет вызван при отмене поиска (пользователь
   * изменил строку поиска, автокомплит потерял фокус).
   * ```
   * function(pattern) {
   *   return service.findAll(pattern);
   * }
   * ```
   */
  source: PropTypes.oneOfType([PropTypes.array, PropTypes.func])
};
Autocomplete.defaultProps = {
  renderItem: renderItem,
  size: 'small',
  disablePortal: false,
  hasShadow: true,
  menuMaxHeight: 300,
  menuAlign: 'left',
  preventWindowScroll: true
};