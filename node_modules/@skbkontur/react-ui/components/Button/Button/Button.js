import _extends from "@babel/runtime/helpers/esm/extends";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import cn from 'classnames';
import { isIE11, isEdge } from "../../../lib/utils";
import { tabListener } from "../../../lib/events/tabListener";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { jsStyles } from "../Button.styles";
import { Corners } from "../Corners";
export var Button =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Button, _React$Component);

  function Button() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      focusedByTab: false
    };
    _this.theme = void 0;
    _this.node = null;

    _this.handleFocus = function (e) {
      if (!_this.props.disabled && !_this.props.disableFocus) {
        // focus event fires before keyDown eventlistener
        // so we should check tabPressed in async way
        process.nextTick(function () {
          if (tabListener.isTabPressed) {
            _this.setState({
              focusedByTab: true
            });
          }
        });
        _this.props.onFocus == null ? void 0 : _this.props.onFocus(e);
      }
    };

    _this.handleBlur = function (e) {
      _this.setState({
        focusedByTab: false
      });

      if (!_this.props.disabled && !_this.props.disableFocus) {
        _this.props.onBlur == null ? void 0 : _this.props.onBlur(e);
      }
    };

    _this._ref = function (node) {
      _this.node = node;
    };

    return _this;
  }

  var _proto = Button.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.autoFocus) {
      tabListener.isTabPressed = true;
      this.focus();
    }
  }
  /**
   * @public
   */
  ;

  _proto.focus = function focus() {
    var _this$node;

    (_this$node = this.node) == null ? void 0 : _this$node.focus();
  }
  /**
   * @public
   */
  ;

  _proto.blur = function blur() {
    var _this$node2;

    (_this$node2 = this.node) == null ? void 0 : _this$node2.blur();
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  };

  _proto.renderMain = function renderMain() {
    var _cn, _cn2;

    var _this$props$corners = this.props.corners,
        corners = _this$props$corners === void 0 ? 0 : _this$props$corners;
    var sizeClass = this.getSizeClassName();
    var isError = !!this.props.error;
    var isWarning = !!this.props.warning;
    var rootProps = {
      // By default the type attribute is 'submit'. IE8 will fire a click event
      // on this button if somewhere on the page user presses Enter while some
      // input is focused. So we set type to 'button' by default.
      type: this.props.type,
      className: cn((_cn = {}, _cn[jsStyles.root(this.theme)] = true, _cn[jsStyles[this.props.use] && jsStyles[this.props.use](this.theme) || jsStyles["default"](this.theme)] = true, _cn[jsStyles.active(this.theme)] = !!this.props.active, _cn[jsStyles.validationRoot(this.theme)] = isError || isWarning, _cn[jsStyles.error(this.theme)] = isError, _cn[jsStyles.warning(this.theme)] = isWarning, _cn[jsStyles.narrow()] = !!this.props.narrow, _cn[jsStyles.noPadding()] = !!this.props._noPadding, _cn[jsStyles.noRightPadding()] = !!this.props._noRightPadding, _cn[jsStyles.buttonWithIcon()] = !!this.props.icon, _cn[sizeClass] = true, _cn[jsStyles.borderless(this.theme)] = !!this.props.borderless, _cn[jsStyles.focus(this.theme)] = this.state.focusedByTab || !!this.props.visuallyFocused, _cn[jsStyles.checked(this.theme)] = !!this.props.checked && !this.props.disabled, _cn[jsStyles.disabled(this.theme)] = !!this.props.disabled || !!this.props.loading, _cn[jsStyles.fallback(this.theme)] = isIE11 || isEdge, _cn)),
      style: {
        borderTopLeftRadius: corners & Corners.TOP_LEFT ? 0 : undefined,
        borderTopRightRadius: corners & Corners.TOP_RIGHT ? 0 : undefined,
        borderBottomRightRadius: corners & Corners.BOTTOM_RIGHT ? 0 : undefined,
        borderBottomLeftRadius: corners & Corners.BOTTOM_LEFT ? 0 : undefined,
        textAlign: this.props.align
      },
      disabled: this.props.disabled || this.props.loading,
      onClick: this.props.onClick,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onKeyDown: this.props.onKeyDown,
      onMouseEnter: this.props.onMouseEnter,
      onMouseLeave: this.props.onMouseLeave,
      onMouseOver: this.props.onMouseOver,
      tabIndex: this.props.disableFocus ? -1 : 0
    };
    var wrapProps = {
      className: cn((_cn2 = {}, _cn2[jsStyles.wrap(this.theme)] = true, _cn2[jsStyles.wrapArrow()] = this.props.arrow === true, _cn2[jsStyles.wrapArrowLeft()] = this.props.arrow === 'left', _cn2)),
      style: {
        width: this.props.width
      }
    };
    var error = null;

    if (this.props.error) {
      error = React.createElement("div", {
        className: jsStyles.error(this.theme)
      });
    } else if (this.props.warning) {
      error = React.createElement("div", {
        className: jsStyles.warning(this.theme)
      });
    }

    var loading = null;

    if (this.props.loading) {
      loading = React.createElement("div", {
        className: jsStyles.loading()
      });
    }

    var icon = this.props.icon;

    if (this.props.icon) {
      icon = React.createElement("span", {
        className: jsStyles.icon()
      }, this.props.icon);
    }

    var arrow = null;

    if (this.props.arrow) {
      var _cn3;

      arrow = React.createElement("div", {
        className: cn((_cn3 = {}, _cn3[jsStyles.arrowWarning(this.theme)] = isWarning, _cn3[jsStyles.arrowError(this.theme)] = isError, _cn3[jsStyles.arrow()] = true, _cn3[jsStyles.arrowLeft(this.theme)] = this.props.arrow === 'left', _cn3))
      });
    } // Force disable all props and features, that cannot be use with Link


    if (this.props.use === 'link') {
      var _cn4, _cn5;

      rootProps.className = cn((_cn4 = {}, _cn4[jsStyles.root(this.theme)] = true, _cn4[jsStyles.buttonWithIcon()] = !!this.props.icon, _cn4[sizeClass] = true, _cn4[jsStyles.focus(this.theme)] = this.state.focusedByTab || !!this.props.visuallyFocused, _cn4[jsStyles.link(this.theme)] = true, _cn4[jsStyles.disabled(this.theme)] = !!this.props.disabled, _cn4));
      Object.assign(wrapProps, {
        className: cn(jsStyles.wrap(this.theme), (_cn5 = {}, _cn5[jsStyles.wrapLink(this.theme)] = this.props.use === 'link', _cn5)),
        style: {
          width: wrapProps.style.width
        }
      });
      rootProps.style.textAlign = undefined;
      loading = null;
      arrow = null;
    }

    return React.createElement("span", wrapProps, React.createElement("button", _extends({
      ref: this._ref
    }, rootProps), error, loading, arrow, React.createElement("div", {
      className: jsStyles.caption()
    }, icon, this.props.children)));
  };

  _proto.getSizeClassName = function getSizeClassName() {
    var _cn6, _cn7, _cn8;

    switch (this.props.size) {
      case 'large':
        return cn(jsStyles.sizeLarge(this.theme), (_cn6 = {}, _cn6[jsStyles.sizeLargeLoading(this.theme)] = this.props.loading, _cn6));

      case 'medium':
        return cn(jsStyles.sizeMedium(this.theme), (_cn7 = {}, _cn7[jsStyles.sizeMediumLoading(this.theme)] = this.props.loading, _cn7));

      case 'small':
      default:
        return cn(jsStyles.sizeSmall(this.theme), (_cn8 = {}, _cn8[jsStyles.sizeSmallLoading(this.theme)] = this.props.loading, _cn8));
    }
  };

  return Button;
}(React.Component);
Button.__KONTUR_REACT_UI__ = 'Button';
Button.__BUTTON__ = true;
Button.TOP_LEFT = Corners.TOP_LEFT;
Button.TOP_RIGHT = Corners.TOP_RIGHT;
Button.BOTTOM_RIGHT = Corners.BOTTOM_RIGHT;
Button.BOTTOM_LEFT = Corners.BOTTOM_LEFT;
Button.defaultProps = {
  use: 'default',
  size: 'small',
  type: 'button'
};
export var isButton = function isButton(child) {
  return React.isValidElement(child) ? Object.prototype.hasOwnProperty.call(child.type, '__BUTTON__') : false;
};