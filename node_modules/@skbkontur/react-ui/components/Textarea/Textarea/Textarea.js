import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import React from 'react';
import PropTypes from 'prop-types';
import throttle from 'lodash.throttle';
import cn from 'classnames';
import { isKeyEnter } from "../../../lib/events/keyboard/identifiers";
import { polyfillPlaceholder } from "../../../lib/polyfillPlaceholder";
import * as LayoutEvents from "../../../lib/LayoutEvents";
import { ThemeContext } from "../../../lib/theming/ThemeContext";
import { getTextAreaHeight } from "../TextareaHelpers";
import { jsStyles } from "../Textarea.styles";
var DEFAULT_WIDTH = 250;
/**
                          * Компонент для ввода многострочного текста.
                          *
                          * Принимает все атрибуты `React.TextareaHTMLAttributes<HTMLTextAreaElement>`
                          *
                          * ** `className` и `style`  игнорируются**
                          */

export var Textarea =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Textarea, _React$Component);

  function Textarea() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      polyfillPlaceholder: polyfillPlaceholder,
      rows: 1
    };
    _this.theme = void 0;
    _this.node = void 0;
    _this.fakeNode = void 0;
    _this.layoutEvents = void 0;

    _this.setSelectionRange = function (start, end) {
      if (!_this.node) {
        throw new Error('Cannot call "setSelectionRange" on unmounted Input');
      }

      if (document.activeElement !== _this.node) {
        _this.focus();
      }

      _this.node.setSelectionRange(start, end);
    };

    _this.selectAll = function () {
      if (_this.node) {
        _this.setSelectionRange(0, _this.node.value.length);
      }
    };

    _this.handleKeyDown = function (e) {
      // Edge bug: textarea maxlength doesn't work after new line
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18833616/
      var value = _this.props.value !== undefined ? _this.props.value.toString() : null;

      var isBlockEnter = isKeyEnter(e) && value !== null && value.length === _this.props.maxLength;

      if (isBlockEnter) {
        e.preventDefault();
      }

      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }
    };

    _this.handleChange = function (e) {
      if (polyfillPlaceholder) {
        var fieldIsEmpty = e.target.value === '';

        if (_this.state.polyfillPlaceholder !== fieldIsEmpty) {
          _this.setState({
            polyfillPlaceholder: fieldIsEmpty
          });
        }
      }

      if (_this.props.onValueChange) {
        _this.props.onValueChange(e.target.value);
      }

      if (_this.props.autoResize) {
        _this.autoResize();
      }

      if (_this.props.onChange) {
        _this.props.onChange(e);
      }
    };

    _this.ref = function (element) {
      _this.node = element;
    };

    _this.refFake = function (element) {
      _this.fakeNode = element;
    };

    _this.autoResize = throttle(function () {
      var fakeNode = _this.fakeNode;

      if (!fakeNode) {
        return;
      }

      var node = _this.node;

      if (!node) {
        return;
      }

      if (_this.props.value === undefined) {
        fakeNode.value = node.value;
      }

      var _this$props = _this.props,
          rows = _this$props.rows,
          maxRows = _this$props.maxRows;

      if (rows === undefined || maxRows === undefined) {
        return;
      }

      var _getTextAreaHeight = getTextAreaHeight(fakeNode, typeof rows === 'number' ? rows : parseInt(rows, 10), typeof maxRows === 'number' ? maxRows : parseInt(maxRows, 10)),
          height = _getTextAreaHeight.height,
          exceededMaxHeight = _getTextAreaHeight.exceededMaxHeight;

      node.style.height = height + 'px';
      node.style.overflowY = exceededMaxHeight ? 'scroll' : 'hidden';
      fakeNode.style.overflowY = exceededMaxHeight ? 'scroll' : 'hidden';
    }, 100);

    _this.handleCut = function (event) {
      if (_this.props.autoResize) {
        _this.autoResize();
      }

      if (_this.props.onPaste) {
        _this.props.onPaste(event);
      }
    };

    _this.handlePaste = function (event) {
      if (_this.props.autoResize) {
        _this.autoResize();
      }

      if (_this.props.onCut) {
        _this.props.onCut(event);
      }
    };

    _this.handleFocus = function (event) {
      if (_this.props.selectAllOnFocus) {
        _this.selectAll();
      }

      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };

    return _this;
  }

  var _proto = Textarea.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.autoResize) {
      this.autoResize();
      this.layoutEvents = LayoutEvents.addListener(this.autoResize);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.layoutEvents) {
      this.layoutEvents.remove();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.autoResize && this.props.rows > this.state.rows || this.props.value !== prevProps.value) {
      this.autoResize();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(ThemeContext.Consumer, null, function (theme) {
      _this2.theme = theme;
      return _this2.renderMain();
    });
  }
  /**
   * @public
   */
  ;

  _proto.focus = function focus() {
    if (this.node) {
      this.node.focus();
    }
  }
  /**
   * @public
   */
  ;

  _proto.blur = function blur() {
    if (this.node) {
      this.node.blur();
    }
  }
  /**
   * @public
   */
  ;

  _proto.renderMain = function renderMain() {
    var _cn;

    var _this$props2 = this.props,
        _this$props2$width = _this$props2.width,
        width = _this$props2$width === void 0 ? DEFAULT_WIDTH : _this$props2$width,
        error = _this$props2.error,
        warning = _this$props2.warning,
        autoResize = _this$props2.autoResize,
        resize = _this$props2.resize,
        onCut = _this$props2.onCut,
        onPaste = _this$props2.onPaste,
        maxRows = _this$props2.maxRows,
        onFocus = _this$props2.onFocus,
        selectAllOnFocus = _this$props2.selectAllOnFocus,
        className = _this$props2.className,
        style = _this$props2.style,
        placeholder = _this$props2.placeholder,
        onValueChange = _this$props2.onValueChange,
        textareaProps = _objectWithoutPropertiesLoose(_this$props2, ["width", "error", "warning", "autoResize", "resize", "onCut", "onPaste", "maxRows", "onFocus", "selectAllOnFocus", "className", "style", "placeholder", "onValueChange"]);

    var rootProps = {
      style: {
        width: width
      }
    };
    var textareaClassNames = cn((_cn = {}, _cn[jsStyles.textarea(this.theme)] = true, _cn[jsStyles.error(this.theme)] = !!error, _cn[jsStyles.warning(this.theme)] = !!warning, _cn));
    var textAreaStyle = {
      resize: autoResize ? 'none' : resize
    };
    var placeholderPolyfill = null;

    if (this.state.polyfillPlaceholder && !textareaProps.value) {
      placeholderPolyfill = React.createElement("span", {
        className: jsStyles.placeholder()
      }, placeholder);
    }

    var fakeTextarea = null;

    if (autoResize) {
      var fakeProps = {
        value: this.props.value,
        defaultValue: this.props.defaultValue,
        className: cn(textareaClassNames, jsStyles.fake()),
        readOnly: true
      };
      fakeTextarea = React.createElement("textarea", _extends({}, fakeProps, {
        ref: this.refFake
      }));
    }

    return React.createElement("label", _extends({}, rootProps, {
      className: jsStyles.root(this.theme)
    }), placeholderPolyfill, React.createElement("textarea", _extends({}, textareaProps, {
      className: textareaClassNames,
      style: textAreaStyle,
      placeholder: !placeholderPolyfill ? placeholder : undefined,
      ref: this.ref,
      onChange: this.handleChange,
      onCut: this.handleCut,
      onPaste: this.handlePaste,
      onFocus: this.handleFocus,
      onKeyDown: this.handleKeyDown
    })), fakeTextarea);
  };

  return Textarea;
}(React.Component);
Textarea.__KONTUR_REACT_UI__ = 'Textarea';
Textarea.propTypes = {
  error: PropTypes.bool,
  warning: PropTypes.bool,
  disabled: PropTypes.bool,
  autoResize: PropTypes.bool,
  maxRows: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  resize: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  id: PropTypes.string,
  name: PropTypes.string,
  title: PropTypes.string,
  spellCheck: PropTypes.bool,
  role: PropTypes.string,
  maxLength: PropTypes.number,
  tabIndex: PropTypes.number,
  rows: PropTypes.number,
  placeholder: PropTypes.string,
  value: PropTypes.string,
  defaultValue: PropTypes.string,
  onValueChange: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseMove: PropTypes.func,
  onMouseOut: PropTypes.func,
  onMouseUp: PropTypes.func,
  onMouseDown: PropTypes.func,
  onClick: PropTypes.func,
  onDoubleClick: PropTypes.func,
  onKeyDown: PropTypes.func,
  onKeyPress: PropTypes.func,
  onKeyUp: PropTypes.func,
  onInput: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onScroll: PropTypes.func,
  onWheel: PropTypes.func,
  onCut: PropTypes.func,
  onPaste: PropTypes.func,
  onCopy: PropTypes.func
};
Textarea.defaultProps = {
  rows: 3,
  maxRows: 15
};